"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/./services/routeOptimizationService.ts":
/*!**********************************************!*\
  !*** ./services/routeOptimizationService.ts ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouteOptimizationService: () => (/* binding */ RouteOptimizationService),\n/* harmony export */   routeOptimizationService: () => (/* binding */ routeOptimizationService)\n/* harmony export */ });\nclass RouteOptimizationService {\n    clearExpiredCache() {\n        const now = Date.now();\n        for (const [key, value] of this.routeCache.entries()){\n            if (now - value.timestamp > this.CACHE_EXPIRY) {\n                this.routeCache.delete(key);\n            }\n        }\n    }\n    getCacheKey(options) {\n        const { startLocation, passengers, destination, optimizeOrder } = options;\n        const startKey = \"\".concat(startLocation.lat(), \",\").concat(startLocation.lng());\n        const destKey = \"\".concat(destination.lat(), \",\").concat(destination.lng());\n        const passengersKey = passengers.map((p)=>\"\".concat(p.id, \"-\").concat(p.position.lat, \",\").concat(p.position.lng)).sort().join('|');\n        return \"\".concat(startKey, \"-\").concat(destKey, \"-\").concat(passengersKey, \"-\").concat(optimizeOrder);\n    }\n    async initializeService() {\n        var _window_google_maps, _window_google;\n        // Aguarda o carregamento da API do Google Maps\n        await this.waitForGoogleMapsAPI();\n        if ((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_maps = _window_google.maps) === null || _window_google_maps === void 0 ? void 0 : _window_google_maps.DirectionsService) {\n            this.directionsService = new google.maps.DirectionsService();\n        }\n    }\n    waitForGoogleMapsAPI() {\n        return new Promise((resolve, reject)=>{\n            try {\n                var _window_google_maps, _window_google;\n                // Se já estiver carregada\n                if (window.googleMapsApiLoaded === true && ((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_maps = _window_google.maps) === null || _window_google_maps === void 0 ? void 0 : _window_google_maps.DirectionsService)) {\n                    resolve();\n                    return;\n                }\n                // Se houve erro no carregamento\n                if (window.googleMapsApiLoaded === 'error') {\n                    const error = new Error('Google Maps API falhou ao carregar. Verifique se a chave da API está configurada corretamente e se as APIs necessárias estão habilitadas (Maps JavaScript API, Directions API, Geometry API).');\n                    error.code = 'GOOGLE_MAPS_NOT_LOADED';\n                    reject(error);\n                    return;\n                }\n                // Aguarda o carregamento\n                let attempts = 0;\n                const maxAttempts = 50; // 5 segundos máximo\n                const checkInterval = setInterval(()=>{\n                    var _window_google_maps, _window_google;\n                    attempts++;\n                    if (window.googleMapsApiLoaded === true && ((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_maps = _window_google.maps) === null || _window_google_maps === void 0 ? void 0 : _window_google_maps.DirectionsService)) {\n                        clearInterval(checkInterval);\n                        resolve();\n                    } else if (window.googleMapsApiLoaded === 'error' || attempts >= maxAttempts) {\n                        clearInterval(checkInterval);\n                        const error = new Error('Timeout ou erro ao carregar Google Maps API. Verifique se a chave da API está configurada corretamente e se as APIs necessárias estão habilitadas (Maps JavaScript API, Directions API, Geometry API).');\n                        error.code = 'GOOGLE_MAPS_NOT_LOADED';\n                        error.details = \"Tentativas: \".concat(attempts, \"/\").concat(maxAttempts);\n                        reject(error);\n                    }\n                }, 100);\n            } catch (error) {\n                const routeError = new Error(\"Erro inesperado ao aguardar Google Maps API: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n                routeError.code = 'UNKNOWN_ERROR';\n                reject(routeError);\n            }\n        });\n    }\n    /**\n     * Calcula a distância entre dois pontos usando a fórmula de Haversine com cache\n     * Força recompilação\n     */ calculateDistance(lat1, lng1, lat2, lng2) {\n        // Cria chave para cache (arredonda para 6 casas decimais para evitar cache excessivo)\n        const key = \"\".concat(lat1.toFixed(6), \",\").concat(lng1.toFixed(6), \"-\").concat(lat2.toFixed(6), \",\").concat(lng2.toFixed(6));\n        // Verifica cache\n        if (this.distanceCache.has(key)) {\n            return this.distanceCache.get(key);\n        }\n        const R = 6371; // Raio da Terra em km\n        const dLat = this.toRad(lat2 - lat1);\n        const dLng = this.toRad(lng2 - lng1);\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        const distance = R * c;\n        // Armazena no cache (limita tamanho do cache)\n        if (this.distanceCache.size < 1000) {\n            this.distanceCache.set(key, distance);\n        }\n        return distance;\n    }\n    toRad(value) {\n        return value * Math.PI / 180;\n    }\n    /**\n     * Algoritmo de otimização usando Nearest Neighbor com melhorias e 2-opt\n     */ optimizePassengerOrder(startLocation, passengers, destination) {\n        if (passengers.length <= 1) return passengers;\n        // Primeiro, aplica Nearest Neighbor\n        let optimizedOrder = this.nearestNeighborOptimization(startLocation, passengers, destination);\n        // Em seguida, aplica 2-opt para melhorar a rota\n        if (optimizedOrder.length > 3) {\n            optimizedOrder = this.twoOptImprovement(startLocation, optimizedOrder, destination);\n        }\n        return optimizedOrder;\n    }\n    /**\n     * Algoritmo Nearest Neighbor básico\n     */ nearestNeighborOptimization(startLocation, passengers, destination) {\n        const unvisited = [\n            ...passengers\n        ];\n        const optimizedOrder = [];\n        let currentLocation = startLocation;\n        while(unvisited.length > 0){\n            let nearestIndex = 0;\n            let nearestDistance = this.calculateDistance(currentLocation.lat(), currentLocation.lng(), unvisited[0].position.lat, unvisited[0].position.lng);\n            // Encontra o passageiro mais próximo\n            for(let i = 1; i < unvisited.length; i++){\n                const distance = this.calculateDistance(currentLocation.lat(), currentLocation.lng(), unvisited[i].position.lat, unvisited[i].position.lng);\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    nearestIndex = i;\n                }\n            }\n            // Adiciona o passageiro mais próximo à rota otimizada\n            const nearestPassenger = unvisited.splice(nearestIndex, 1)[0];\n            optimizedOrder.push(nearestPassenger);\n            currentLocation = new google.maps.LatLng(nearestPassenger.position.lat, nearestPassenger.position.lng);\n        }\n        return optimizedOrder;\n    }\n    /**\n     * Algoritmo 2-opt para melhorar a rota existente\n     */ twoOptImprovement(startLocation, route, destination) {\n        let improved = true;\n        let bestRoute = [\n            ...route\n        ];\n        let bestDistance = this.calculateTotalRouteDistance(startLocation, bestRoute, destination);\n        while(improved){\n            improved = false;\n            for(let i = 1; i < route.length - 2; i++){\n                for(let j = i + 1; j < route.length; j++){\n                    if (j - i === 1) continue; // Skip adjacent edges\n                    // Cria nova rota com 2-opt swap\n                    const newRoute = this.twoOptSwap(route, i, j);\n                    const newDistance = this.calculateTotalRouteDistance(startLocation, newRoute, destination);\n                    if (newDistance < bestDistance) {\n                        bestRoute = newRoute;\n                        bestDistance = newDistance;\n                        route = newRoute;\n                        improved = true;\n                    }\n                }\n            }\n        }\n        return bestRoute;\n    }\n    /**\n     * Executa o swap 2-opt\n     */ twoOptSwap(route, i, j) {\n        const newRoute = [\n            ...route\n        ];\n        // Reverte a ordem dos elementos entre i e j\n        while(i < j){\n            [newRoute[i], newRoute[j]] = [\n                newRoute[j],\n                newRoute[i]\n            ];\n            i++;\n            j--;\n        }\n        return newRoute;\n    }\n    /**\n     * Calcula a distância total de uma rota\n     */ calculateTotalRouteDistance(startLocation, route, destination) {\n        let totalDistance = 0;\n        let currentLocation = startLocation;\n        // Distância do início até o primeiro passageiro\n        if (route.length > 0) {\n            totalDistance += this.calculateDistance(currentLocation.lat(), currentLocation.lng(), route[0].position.lat, route[0].position.lng);\n        }\n        // Distância entre passageiros\n        for(let i = 0; i < route.length - 1; i++){\n            totalDistance += this.calculateDistance(route[i].position.lat, route[i].position.lng, route[i + 1].position.lat, route[i + 1].position.lng);\n        }\n        // Distância do último passageiro até o destino\n        if (route.length > 0) {\n            totalDistance += this.calculateDistance(route[route.length - 1].position.lat, route[route.length - 1].position.lng, destination.lat(), destination.lng());\n        }\n        return totalDistance;\n    }\n    /**\n     * Calcula horários estimados de coleta baseados na rota otimizada\n     */ calculatePickupTimes(startLocation, optimizedPassengers) {\n        let startTime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Date();\n        const pickupTimes = [];\n        let currentTime = new Date(startTime);\n        let currentLocation = startLocation;\n        // Velocidade média estimada (km/h) - pode ser configurável\n        const averageSpeed = 30; // 30 km/h em área urbana\n        const stopTime = 2; // 2 minutos por parada\n        for (const passenger of optimizedPassengers){\n            // Calcula distância até o passageiro\n            const distance = this.calculateDistance(currentLocation.lat(), currentLocation.lng(), passenger.position.lat, passenger.position.lng);\n            // Calcula tempo de viagem em minutos\n            const travelTimeMinutes = distance / averageSpeed * 60;\n            // Adiciona tempo de viagem ao tempo atual\n            currentTime = new Date(currentTime.getTime() + travelTimeMinutes * 60000);\n            pickupTimes.push({\n                passenger,\n                estimatedPickupTime: new Date(currentTime)\n            });\n            // Adiciona tempo de parada\n            currentTime = new Date(currentTime.getTime() + stopTime * 60000);\n            // Atualiza localização atual\n            currentLocation = new google.maps.LatLng(passenger.position.lat, passenger.position.lng);\n        }\n        return pickupTimes;\n    }\n    /**\n     * Calcula a rota otimizada usando Google Directions API\n     */ async calculateOptimizedRoute(options) {\n        const { startLocation, passengers, destination, optimizeOrder = true } = options;\n        try {\n            // Verifica cache primeiro\n            const cacheKey = this.getCacheKey(options);\n            if (this.routeCache.has(cacheKey)) {\n                const cachedRoute = this.routeCache.get(cacheKey);\n                console.log('Rota encontrada no cache');\n                return cachedRoute;\n            }\n            // Aguarda a inicialização do serviço se necessário\n            if (!this.directionsService) {\n                await this.initializeService();\n            }\n            if (!this.directionsService) {\n                const error = new Error('Google Maps API não está carregada');\n                error.code = 'GOOGLE_MAPS_NOT_LOADED';\n                throw error;\n            }\n            // Validação dos parâmetros de entrada\n            if (!startLocation || !destination) {\n                const error = new Error('Coordenadas de início ou destino não fornecidas');\n                error.code = 'INVALID_COORDINATES';\n                throw error;\n            }\n            // Validação específica para objetos LatLng\n            try {\n                const startLat = typeof startLocation.lat === 'function' ? startLocation.lat() : startLocation.lat;\n                const startLng = typeof startLocation.lng === 'function' ? startLocation.lng() : startLocation.lng;\n                const destLat = typeof destination.lat === 'function' ? destination.lat() : destination.lat;\n                const destLng = typeof destination.lng === 'function' ? destination.lng() : destination.lng;\n                if (typeof startLat !== 'number' || typeof startLng !== 'number' || typeof destLat !== 'number' || typeof destLng !== 'number' || isNaN(startLat) || isNaN(startLng) || isNaN(destLat) || isNaN(destLng)) {\n                    const error = new Error('Coordenadas de início ou destino são inválidas');\n                    error.code = 'INVALID_COORDINATES';\n                    error.details = \"Start: \".concat(startLat, \", \").concat(startLng, \" | Dest: \").concat(destLat, \", \").concat(destLng);\n                    throw error;\n                }\n            } catch (error) {\n                const routeError = new Error(\"Erro ao validar coordenadas: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n                routeError.code = 'INVALID_COORDINATES';\n                throw routeError;\n            }\n            if (!passengers || passengers.length === 0) {\n                const error = new Error('Lista de passageiros não fornecida ou vazia');\n                error.code = 'NO_PASSENGERS';\n                throw error;\n            }\n        } catch (error) {\n            if (error.code) {\n                throw error;\n            }\n            const routeError = new Error(\"Erro inesperado na valida\\xe7\\xe3o inicial: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n            routeError.code = 'UNKNOWN_ERROR';\n            throw routeError;\n        }\n        // Valida coordenadas de todos os passageiros\n        for (const passenger of passengers){\n            if (!passenger.position || typeof passenger.position.lat !== 'number' || typeof passenger.position.lng !== 'number' || isNaN(passenger.position.lat) || isNaN(passenger.position.lng)) {\n                const error = new Error(\"Coordenadas inv\\xe1lidas para o passageiro \".concat(passenger.name || 'desconhecido'));\n                error.code = 'INVALID_COORDINATES';\n                error.details = \"Passageiro: \".concat(passenger.name, \", Posi\\xe7\\xe3o: \").concat(JSON.stringify(passenger.position));\n                throw error;\n            }\n        }\n        // Otimiza a ordem dos passageiros se solicitado\n        const orderedPassengers = optimizeOrder ? this.optimizePassengerOrder(startLocation, passengers, destination) : passengers;\n        // Prepara os waypoints para a API do Google\n        const waypoints = orderedPassengers.map((passenger)=>{\n            try {\n                // Validação adicional antes de criar LatLng\n                if (!passenger.position || typeof passenger.position.lat !== 'number' || typeof passenger.position.lng !== 'number' || isNaN(passenger.position.lat) || isNaN(passenger.position.lng)) {\n                    throw new Error(\"Coordenadas inv\\xe1lidas para passageiro \".concat(passenger.name));\n                }\n                return {\n                    location: new google.maps.LatLng(passenger.position.lat, passenger.position.lng),\n                    stopover: true\n                };\n            } catch (error) {\n                console.error(\"Erro ao criar waypoint para passageiro \".concat(passenger.name, \":\"), error);\n                throw error;\n            }\n        });\n        return new Promise((resolve, reject)=>{\n            try {\n                const request = {\n                    origin: startLocation,\n                    destination: destination,\n                    waypoints: waypoints,\n                    travelMode: google.maps.TravelMode.DRIVING,\n                    optimizeWaypoints: false // Usamos nossa própria otimização\n                };\n                this.directionsService.route(request, (directionsResult, status)=>{\n                    try {\n                        if (status === google.maps.DirectionsStatus.OK && directionsResult) {\n                            const route = directionsResult.routes[0];\n                            const leg = route.legs;\n                            // Calcula distância e duração total\n                            let totalDistance = 0;\n                            let totalDuration = 0;\n                            leg.forEach((segment)=>{\n                                if (segment.distance) totalDistance += segment.distance.value;\n                                if (segment.duration) totalDuration += segment.duration.value;\n                            });\n                            // Extrai o caminho da polyline com validação\n                            const polylinePath = [];\n                            if (route.overview_path && Array.isArray(route.overview_path)) {\n                                route.overview_path.forEach((point)=>{\n                                    try {\n                                        // Valida se o ponto tem coordenadas válidas\n                                        const lat = typeof point.lat === 'function' ? point.lat() : point.lat;\n                                        const lng = typeof point.lng === 'function' ? point.lng() : point.lng;\n                                        if (typeof lat === 'number' && typeof lng === 'number' && !isNaN(lat) && !isNaN(lng)) {\n                                            polylinePath.push(point);\n                                        }\n                                    } catch (error) {\n                                        console.warn('Erro ao processar ponto do polyline:', error);\n                                    }\n                                });\n                            }\n                            // Cria os waypoints ordenados com validação\n                            const optimizedWaypoints = [\n                                startLocation\n                            ];\n                            orderedPassengers.forEach((passenger)=>{\n                                try {\n                                    if (passenger.position && typeof passenger.position.lat === 'number' && typeof passenger.position.lng === 'number' && !isNaN(passenger.position.lat) && !isNaN(passenger.position.lng)) {\n                                        optimizedWaypoints.push(new google.maps.LatLng(passenger.position.lat, passenger.position.lng));\n                                    }\n                                } catch (error) {\n                                    console.warn(\"Erro ao criar waypoint para passageiro \".concat(passenger.name, \":\"), error);\n                                }\n                            });\n                            optimizedWaypoints.push(destination);\n                            // Calcula horários estimados de pickup\n                            const pickupTimes = this.calculatePickupTimes(startLocation, orderedPassengers, new Date());\n                            const result = {\n                                waypoints: optimizedWaypoints,\n                                orderedPassengers,\n                                totalDistance: totalDistance / 1000,\n                                totalDuration: totalDuration / 60,\n                                polylinePath,\n                                pickupTimes\n                            };\n                            // Armazena no cache\n                            result.timestamp = Date.now();\n                            const cacheKey = this.getCacheKey(options);\n                            this.routeCache.set(cacheKey, result);\n                            resolve(result);\n                        } else {\n                            const error = new Error(\"Falha ao calcular rota: \".concat(status));\n                            error.code = 'DIRECTIONS_API_ERROR';\n                            error.details = \"Status: \".concat(status);\n                            reject(error);\n                        }\n                    } catch (error) {\n                        const routeError = new Error(\"Erro ao processar resultado da rota: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n                        routeError.code = 'UNKNOWN_ERROR';\n                        reject(routeError);\n                    }\n                });\n            } catch (error) {\n                const routeError = new Error(\"Erro ao criar requisi\\xe7\\xe3o de rota: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n                routeError.code = 'UNKNOWN_ERROR';\n                reject(routeError);\n            }\n        });\n    }\n    /**\n     * Encontra a melhor rota possível, com fallback para rota não otimizada\n     */ async findBestRoute(options) {\n        try {\n            // Aguarda a inicialização do serviço se necessário\n            if (!this.directionsService) {\n                await this.initializeService();\n            }\n            // Tenta calcular rota otimizada\n            return await this.calculateOptimizedRoute(options);\n        } catch (error) {\n            console.warn('Erro ao calcular rota otimizada:', error);\n            // Fallback: rota sem otimização\n            try {\n                return await this.calculateOptimizedRoute({\n                    ...options,\n                    optimizeOrder: false\n                });\n            } catch (fallbackError) {\n                console.error('Erro ao calcular rota de fallback:', fallbackError);\n                // Se ainda assim falhar, retorna uma rota básica com dados estimados\n                return this.createFallbackRoute(options);\n            }\n        }\n    }\n    /**\n     * Cria uma rota de fallback com dados estimados quando a API falha\n     */ createFallbackRoute(options) {\n        const { startLocation, passengers, destination } = options;\n        // Validação e conversão de coordenadas para formato simples\n        if (!startLocation || !destination) {\n            throw new Error('Coordenadas de início ou destino não fornecidas');\n        }\n        const startCoords = {\n            lat: typeof startLocation.lat === 'function' ? startLocation.lat() : startLocation.lat,\n            lng: typeof startLocation.lng === 'function' ? startLocation.lng() : startLocation.lng\n        };\n        const destCoords = {\n            lat: typeof destination.lat === 'function' ? destination.lat() : destination.lat,\n            lng: typeof destination.lng === 'function' ? destination.lng() : destination.lng\n        };\n        // Validação das coordenadas convertidas\n        if (typeof startCoords.lat !== 'number' || typeof startCoords.lng !== 'number' || typeof destCoords.lat !== 'number' || typeof destCoords.lng !== 'number') {\n            throw new Error('Coordenadas inválidas fornecidas');\n        }\n        // Validação dos passageiros e suas coordenadas\n        if (!passengers || passengers.length === 0) {\n            throw new Error('Lista de passageiros não fornecida ou vazia');\n        }\n        // Valida coordenadas de todos os passageiros\n        for (const passenger of passengers){\n            if (!passenger.position || typeof passenger.position.lat !== 'number' || typeof passenger.position.lng !== 'number') {\n                throw new Error(\"Coordenadas inv\\xe1lidas para o passageiro \".concat(passenger.name || 'desconhecido'));\n            }\n        }\n        // Calcula distâncias estimadas usando Haversine\n        let totalDistance = 0;\n        let currentCoords = startCoords;\n        for (const passenger of passengers){\n            const currentLat = typeof currentCoords.lat === 'function' ? currentCoords.lat() : currentCoords.lat;\n            const currentLng = typeof currentCoords.lng === 'function' ? currentCoords.lng() : currentCoords.lng;\n            totalDistance += this.calculateDistance(currentLat, currentLng, passenger.position.lat, passenger.position.lng);\n            currentCoords = passenger.position;\n        }\n        // Adiciona distância até o destino\n        const finalLat = typeof currentCoords.lat === 'function' ? currentCoords.lat() : currentCoords.lat;\n        const finalLng = typeof currentCoords.lng === 'function' ? currentCoords.lng() : currentCoords.lng;\n        totalDistance += this.calculateDistance(finalLat, finalLng, destCoords.lat, destCoords.lng);\n        // Estima duração (assumindo velocidade média de 30 km/h no trânsito urbano)\n        const totalDuration = totalDistance / 30 * 60; // em minutos\n        // Calcula horários estimados simplificados para fallback\n        const pickupTimes = [];\n        const startTime = new Date();\n        let currentTime = new Date(startTime);\n        passengers.forEach((passenger, index)=>{\n            // Adiciona tempo estimado baseado na distância\n            const timeToPassenger = (index + 1) * (totalDuration / passengers.length);\n            currentTime = new Date(startTime.getTime() + timeToPassenger * 60 * 1000);\n            pickupTimes.push({\n                passenger,\n                estimatedPickupTime: new Date(currentTime)\n            });\n        });\n        // Cria waypoints básicos para fallback\n        const fallbackWaypoints = [];\n        try {\n            fallbackWaypoints.push(new google.maps.LatLng(startCoords.lat, startCoords.lng));\n            passengers.forEach((passenger)=>{\n                if (passenger.position) {\n                    fallbackWaypoints.push(new google.maps.LatLng(passenger.position.lat, passenger.position.lng));\n                }\n            });\n            fallbackWaypoints.push(new google.maps.LatLng(destCoords.lat, destCoords.lng));\n        } catch (error) {\n            console.warn('Erro ao criar waypoints de fallback:', error);\n        }\n        return {\n            waypoints: fallbackWaypoints,\n            orderedPassengers: passengers,\n            totalDistance,\n            totalDuration,\n            polylinePath: [],\n            pickupTimes\n        };\n    }\n    /**\n     * Estima o tempo de embarque baseado no número de passageiros\n     */ estimateBoardingTime(passengerCount) {\n        // Estima 30 segundos por passageiro + 1 minuto base\n        return 1 + passengerCount * 0.5;\n    }\n    /**\n     * Calcula o horário estimado de chegada para cada passageiro (método alternativo para compatibilidade)\n     */ calculatePickupTimesFromSegments(startTime, orderedPassengers, routeSegments) {\n        const pickupTimes = [];\n        let currentTime = new Date(startTime);\n        orderedPassengers.forEach((passenger, index)=>{\n            if (index < routeSegments.length) {\n                const segment = routeSegments[index];\n                if (segment.duration) {\n                    currentTime = new Date(currentTime.getTime() + segment.duration.value * 1000);\n                }\n            }\n            pickupTimes.push({\n                passenger,\n                estimatedPickupTime: new Date(currentTime)\n            });\n            // Adiciona tempo de embarque\n            const boardingTime = this.estimateBoardingTime(1);\n            currentTime = new Date(currentTime.getTime() + boardingTime * 60 * 1000);\n        });\n        return pickupTimes;\n    }\n    /**\n     * Gera sugestões de otimização para uma rota\n     */ generateOptimizationSuggestion(passengerCount) {\n        if (passengerCount === 0) {\n            return \"Adicione passageiros para ver sugestões de otimização.\";\n        }\n        if (passengerCount === 1) {\n            return \"✅ Rota simples com 1 passageiro - sem necessidade de otimização.\";\n        }\n        if (passengerCount <= 3) {\n            return \"\\uD83D\\uDE8C Rota com \".concat(passengerCount, \" passageiros - otimiza\\xe7\\xe3o autom\\xe1tica aplicada para minimizar dist\\xe2ncia.\");\n        }\n        if (passengerCount <= 6) {\n            return \"\\uD83C\\uDFAF Rota com \".concat(passengerCount, \" passageiros - algoritmo avan\\xe7ado aplicado (Nearest Neighbor + 2-opt) para m\\xe1xima efici\\xeancia.\");\n        }\n        return \"⚡ Rota complexa com \".concat(passengerCount, \" passageiros - otimiza\\xe7\\xe3o inteligente aplicada. Tempo estimado de economia: \").concat(Math.round(passengerCount * 0.8), \" minutos.\");\n    }\n    /**\n     * Valida se um endereço tem coordenadas válidas\n     */ validateAddress(address, position) {\n        if (!address || address.trim().length < 10) {\n            return false;\n        }\n        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number' || isNaN(position.lat) || isNaN(position.lng) || position.lat === 0 && position.lng === 0) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Formata tempo estimado de coleta\n     */ formatPickupTime(estimatedTime) {\n        const now = new Date();\n        const diffMinutes = Math.round((estimatedTime.getTime() - now.getTime()) / (1000 * 60));\n        if (diffMinutes < 0) {\n            return \"Horário passado\";\n        }\n        if (diffMinutes < 60) {\n            return \"\".concat(diffMinutes, \" min\");\n        }\n        const hours = Math.floor(diffMinutes / 60);\n        const minutes = diffMinutes % 60;\n        if (hours < 24) {\n            return \"\".concat(hours, \"h\").concat(minutes > 0 ? \" \".concat(minutes, \"min\") : '');\n        }\n        return estimatedTime.toLocaleDateString('pt-BR', {\n            day: '2-digit',\n            month: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit'\n        });\n    }\n    constructor(){\n        this.directionsService = null;\n        this.distanceCache = new Map();\n        this.routeCache = new Map();\n        this.CACHE_EXPIRY = 5 * 60 * 1000; // 5 minutos\n        this.initializeService();\n        // Limpa cache periodicamente\n        setInterval(()=>this.clearExpiredCache(), 60000); // A cada minuto\n    }\n}\nconst routeOptimizationService = new RouteOptimizationService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3JvdXRlT3B0aW1pemF0aW9uU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQXVCTyxNQUFNQTtJQVlEQyxvQkFBMEI7UUFDOUIsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztRQUNwQixLQUFLLE1BQU0sQ0FBQ0UsS0FBS0MsTUFBTSxJQUFJLElBQUksQ0FBQ0MsVUFBVSxDQUFDQyxPQUFPLEdBQUk7WUFDbEQsSUFBSUwsTUFBTSxNQUFlTSxTQUFTLEdBQUcsSUFBSSxDQUFDQyxZQUFZLEVBQUU7Z0JBQ3BELElBQUksQ0FBQ0gsVUFBVSxDQUFDSSxNQUFNLENBQUNOO1lBQzNCO1FBQ0o7SUFDSjtJQUVRTyxZQUFZQyxPQUFpQyxFQUFVO1FBQzNELE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxVQUFVLEVBQUVDLFdBQVcsRUFBRUMsYUFBYSxFQUFFLEdBQUdKO1FBQ2xFLE1BQU1LLFdBQVcsR0FBMEJKLE9BQXZCQSxjQUFjSyxHQUFHLElBQUcsS0FBdUIsT0FBcEJMLGNBQWNNLEdBQUc7UUFDNUQsTUFBTUMsVUFBVSxHQUF3QkwsT0FBckJBLFlBQVlHLEdBQUcsSUFBRyxLQUFxQixPQUFsQkgsWUFBWUksR0FBRztRQUN2RCxNQUFNRSxnQkFBZ0JQLFdBQ2pCUSxHQUFHLENBQUNDLENBQUFBLElBQUssR0FBV0EsT0FBUkEsRUFBRUMsRUFBRSxFQUFDLEtBQXFCRCxPQUFsQkEsRUFBRUUsUUFBUSxDQUFDUCxHQUFHLEVBQUMsS0FBa0IsT0FBZkssRUFBRUUsUUFBUSxDQUFDTixHQUFHLEdBQ3BETyxJQUFJLEdBQ0pDLElBQUksQ0FBQztRQUNWLE9BQU8sR0FBZVAsT0FBWkgsVUFBUyxLQUFjSSxPQUFYRCxTQUFRLEtBQW9CSixPQUFqQkssZUFBYyxLQUFpQixPQUFkTDtJQUN0RDtJQUVBLE1BQWNZLG9CQUFtQztZQUl6Q0MscUJBQUFBO1FBSEosK0NBQStDO1FBQy9DLE1BQU0sSUFBSSxDQUFDQyxvQkFBb0I7UUFF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ZHJvXFxEb2N1bWVudHNcXGdvbGZmb3hcXHNlcnZpY2VzXFxyb3V0ZU9wdGltaXphdGlvblNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBQYXNzZW5nZXIsIENvbXBhbnkgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW1pemVkUm91dGUge1xuICAgIHdheXBvaW50czogZ29vZ2xlLm1hcHMuTGF0TG5nW107XG4gICAgb3JkZXJlZFBhc3NlbmdlcnM6IFBhc3NlbmdlcltdO1xuICAgIHRvdGFsRGlzdGFuY2U6IG51bWJlcjtcbiAgICB0b3RhbER1cmF0aW9uOiBudW1iZXI7XG4gICAgcG9seWxpbmVQYXRoOiBnb29nbGUubWFwcy5MYXRMbmdbXTtcbiAgICBwaWNrdXBUaW1lcz86IHsgcGFzc2VuZ2VyOiBQYXNzZW5nZXI7IGVzdGltYXRlZFBpY2t1cFRpbWU6IERhdGUgfVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlT3B0aW1pemF0aW9uT3B0aW9ucyB7XG4gICAgc3RhcnRMb2NhdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nO1xuICAgIHBhc3NlbmdlcnM6IFBhc3NlbmdlcltdO1xuICAgIGRlc3RpbmF0aW9uOiBnb29nbGUubWFwcy5MYXRMbmc7XG4gICAgb3B0aW1pemVPcmRlcj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVDYWxjdWxhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvZGU6ICdHT09HTEVfTUFQU19OT1RfTE9BREVEJyB8ICdJTlZBTElEX0NPT1JESU5BVEVTJyB8ICdOT19QQVNTRU5HRVJTJyB8ICdESVJFQ1RJT05TX0FQSV9FUlJPUicgfCAnVU5LTk9XTl9FUlJPUic7XG4gICAgZGV0YWlscz86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFJvdXRlT3B0aW1pemF0aW9uU2VydmljZSB7XG4gICAgcHJpdmF0ZSBkaXJlY3Rpb25zU2VydmljZTogZ29vZ2xlLm1hcHMuRGlyZWN0aW9uc1NlcnZpY2UgfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIGRpc3RhbmNlQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICAgIHByaXZhdGUgcm91dGVDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBPcHRpbWl6ZWRSb3V0ZT4oKTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IENBQ0hFX0VYUElSWSA9IDUgKiA2MCAqIDEwMDA7IC8vIDUgbWludXRvc1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVNlcnZpY2UoKTtcbiAgICAgICAgLy8gTGltcGEgY2FjaGUgcGVyaW9kaWNhbWVudGVcbiAgICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5jbGVhckV4cGlyZWRDYWNoZSgpLCA2MDAwMCk7IC8vIEEgY2FkYSBtaW51dG9cbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyRXhwaXJlZENhY2hlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnJvdXRlQ2FjaGUuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAobm93IC0gKHZhbHVlIGFzIGFueSkudGltZXN0YW1wID4gdGhpcy5DQUNIRV9FWFBJUlkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlQ2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENhY2hlS2V5KG9wdGlvbnM6IFJvdXRlT3B0aW1pemF0aW9uT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRMb2NhdGlvbiwgcGFzc2VuZ2VycywgZGVzdGluYXRpb24sIG9wdGltaXplT3JkZXIgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHN0YXJ0S2V5ID0gYCR7c3RhcnRMb2NhdGlvbi5sYXQoKX0sJHtzdGFydExvY2F0aW9uLmxuZygpfWA7XG4gICAgICAgIGNvbnN0IGRlc3RLZXkgPSBgJHtkZXN0aW5hdGlvbi5sYXQoKX0sJHtkZXN0aW5hdGlvbi5sbmcoKX1gO1xuICAgICAgICBjb25zdCBwYXNzZW5nZXJzS2V5ID0gcGFzc2VuZ2Vyc1xuICAgICAgICAgICAgLm1hcChwID0+IGAke3AuaWR9LSR7cC5wb3NpdGlvbi5sYXR9LCR7cC5wb3NpdGlvbi5sbmd9YClcbiAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgICAgIHJldHVybiBgJHtzdGFydEtleX0tJHtkZXN0S2V5fS0ke3Bhc3NlbmdlcnNLZXl9LSR7b3B0aW1pemVPcmRlcn1gO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZVNlcnZpY2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIC8vIEFndWFyZGEgbyBjYXJyZWdhbWVudG8gZGEgQVBJIGRvIEdvb2dsZSBNYXBzXG4gICAgICAgIGF3YWl0IHRoaXMud2FpdEZvckdvb2dsZU1hcHNBUEkoKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlPy5tYXBzPy5EaXJlY3Rpb25zU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25zU2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5EaXJlY3Rpb25zU2VydmljZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB3YWl0Rm9yR29vZ2xlTWFwc0FQSSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gU2UgasOhIGVzdGl2ZXIgY2FycmVnYWRhXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5nb29nbGVNYXBzQXBpTG9hZGVkID09PSB0cnVlICYmIHdpbmRvdy5nb29nbGU/Lm1hcHM/LkRpcmVjdGlvbnNTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNlIGhvdXZlIGVycm8gbm8gY2FycmVnYW1lbnRvXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5nb29nbGVNYXBzQXBpTG9hZGVkID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ0dvb2dsZSBNYXBzIEFQSSBmYWxob3UgYW8gY2FycmVnYXIuIFZlcmlmaXF1ZSBzZSBhIGNoYXZlIGRhIEFQSSBlc3TDoSBjb25maWd1cmFkYSBjb3JyZXRhbWVudGUgZSBzZSBhcyBBUElzIG5lY2Vzc8OhcmlhcyBlc3TDo28gaGFiaWxpdGFkYXMgKE1hcHMgSmF2YVNjcmlwdCBBUEksIERpcmVjdGlvbnMgQVBJLCBHZW9tZXRyeSBBUEkpLicpIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdHT09HTEVfTUFQU19OT1RfTE9BREVEJztcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFndWFyZGEgbyBjYXJyZWdhbWVudG9cbiAgICAgICAgICAgICAgICBsZXQgYXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNTA7IC8vIDUgc2VndW5kb3MgbcOheGltb1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzKys7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93Lmdvb2dsZU1hcHNBcGlMb2FkZWQgPT09IHRydWUgJiYgd2luZG93Lmdvb2dsZT8ubWFwcz8uRGlyZWN0aW9uc1NlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY2hlY2tJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93Lmdvb2dsZU1hcHNBcGlMb2FkZWQgPT09ICdlcnJvcicgfHwgYXR0ZW1wdHMgPj0gbWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY2hlY2tJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcjogUm91dGVDYWxjdWxhdGlvbkVycm9yID0gbmV3IEVycm9yKCdUaW1lb3V0IG91IGVycm8gYW8gY2FycmVnYXIgR29vZ2xlIE1hcHMgQVBJLiBWZXJpZmlxdWUgc2UgYSBjaGF2ZSBkYSBBUEkgZXN0w6EgY29uZmlndXJhZGEgY29ycmV0YW1lbnRlIGUgc2UgYXMgQVBJcyBuZWNlc3PDoXJpYXMgZXN0w6NvIGhhYmlsaXRhZGFzIChNYXBzIEphdmFTY3JpcHQgQVBJLCBEaXJlY3Rpb25zIEFQSSwgR2VvbWV0cnkgQVBJKS4nKSBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ0dPT0dMRV9NQVBTX05PVF9MT0FERUQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGV0YWlscyA9IGBUZW50YXRpdmFzOiAke2F0dGVtcHRzfS8ke21heEF0dGVtcHRzfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVFcnJvcjogUm91dGVDYWxjdWxhdGlvbkVycm9yID0gbmV3IEVycm9yKGBFcnJvIGluZXNwZXJhZG8gYW8gYWd1YXJkYXIgR29vZ2xlIE1hcHMgQVBJOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Vycm8gZGVzY29uaGVjaWRvJ31gKSBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgcm91dGVFcnJvci5jb2RlID0gJ1VOS05PV05fRVJST1InO1xuICAgICAgICAgICAgICAgIHJlamVjdChyb3V0ZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYSBhIGRpc3TDom5jaWEgZW50cmUgZG9pcyBwb250b3MgdXNhbmRvIGEgZsOzcm11bGEgZGUgSGF2ZXJzaW5lIGNvbSBjYWNoZVxuICAgICAqIEZvcsOnYSByZWNvbXBpbGHDp8Ojb1xuICAgICAqL1xuICAgIHByaXZhdGUgY2FsY3VsYXRlRGlzdGFuY2UobGF0MTogbnVtYmVyLCBsbmcxOiBudW1iZXIsIGxhdDI6IG51bWJlciwgbG5nMjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgLy8gQ3JpYSBjaGF2ZSBwYXJhIGNhY2hlIChhcnJlZG9uZGEgcGFyYSA2IGNhc2FzIGRlY2ltYWlzIHBhcmEgZXZpdGFyIGNhY2hlIGV4Y2Vzc2l2bylcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7bGF0MS50b0ZpeGVkKDYpfSwke2xuZzEudG9GaXhlZCg2KX0tJHtsYXQyLnRvRml4ZWQoNil9LCR7bG5nMi50b0ZpeGVkKDYpfWA7XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZmljYSBjYWNoZVxuICAgICAgICBpZiAodGhpcy5kaXN0YW5jZUNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZUNhY2hlLmdldChrZXkpITtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFIgPSA2MzcxOyAvLyBSYWlvIGRhIFRlcnJhIGVtIGttXG4gICAgICAgIGNvbnN0IGRMYXQgPSB0aGlzLnRvUmFkKGxhdDIgLSBsYXQxKTtcbiAgICAgICAgY29uc3QgZExuZyA9IHRoaXMudG9SYWQobG5nMiAtIGxuZzEpO1xuICAgICAgICBjb25zdCBhID0gTWF0aC5zaW4oZExhdCAvIDIpICogTWF0aC5zaW4oZExhdCAvIDIpICtcbiAgICAgICAgICAgICAgICAgIE1hdGguY29zKHRoaXMudG9SYWQobGF0MSkpICogTWF0aC5jb3ModGhpcy50b1JhZChsYXQyKSkgKlxuICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oZExuZyAvIDIpICogTWF0aC5zaW4oZExuZyAvIDIpO1xuICAgICAgICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBSICogYztcblxuICAgICAgICAvLyBBcm1hemVuYSBubyBjYWNoZSAobGltaXRhIHRhbWFuaG8gZG8gY2FjaGUpXG4gICAgICAgIGlmICh0aGlzLmRpc3RhbmNlQ2FjaGUuc2l6ZSA8IDEwMDApIHtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2VDYWNoZS5zZXQoa2V5LCBkaXN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b1JhZCh2YWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICogTWF0aC5QSSAvIDE4MDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGdvcml0bW8gZGUgb3RpbWl6YcOnw6NvIHVzYW5kbyBOZWFyZXN0IE5laWdoYm9yIGNvbSBtZWxob3JpYXMgZSAyLW9wdFxuICAgICAqL1xuICAgIHByaXZhdGUgb3B0aW1pemVQYXNzZW5nZXJPcmRlcihcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nLFxuICAgICAgICBwYXNzZW5nZXJzOiBQYXNzZW5nZXJbXSxcbiAgICAgICAgZGVzdGluYXRpb246IGdvb2dsZS5tYXBzLkxhdExuZ1xuICAgICk6IFBhc3NlbmdlcltdIHtcbiAgICAgICAgaWYgKHBhc3NlbmdlcnMubGVuZ3RoIDw9IDEpIHJldHVybiBwYXNzZW5nZXJzO1xuXG4gICAgICAgIC8vIFByaW1laXJvLCBhcGxpY2EgTmVhcmVzdCBOZWlnaGJvclxuICAgICAgICBsZXQgb3B0aW1pemVkT3JkZXIgPSB0aGlzLm5lYXJlc3ROZWlnaGJvck9wdGltaXphdGlvbihzdGFydExvY2F0aW9uLCBwYXNzZW5nZXJzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBFbSBzZWd1aWRhLCBhcGxpY2EgMi1vcHQgcGFyYSBtZWxob3JhciBhIHJvdGFcbiAgICAgICAgaWYgKG9wdGltaXplZE9yZGVyLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIG9wdGltaXplZE9yZGVyID0gdGhpcy50d29PcHRJbXByb3ZlbWVudChzdGFydExvY2F0aW9uLCBvcHRpbWl6ZWRPcmRlciwgZGVzdGluYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGltaXplZE9yZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsZ29yaXRtbyBOZWFyZXN0IE5laWdoYm9yIGLDoXNpY29cbiAgICAgKi9cbiAgICBwcml2YXRlIG5lYXJlc3ROZWlnaGJvck9wdGltaXphdGlvbihcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nLFxuICAgICAgICBwYXNzZW5nZXJzOiBQYXNzZW5nZXJbXSxcbiAgICAgICAgZGVzdGluYXRpb246IGdvb2dsZS5tYXBzLkxhdExuZ1xuICAgICk6IFBhc3NlbmdlcltdIHtcbiAgICAgICAgY29uc3QgdW52aXNpdGVkID0gWy4uLnBhc3NlbmdlcnNdO1xuICAgICAgICBjb25zdCBvcHRpbWl6ZWRPcmRlcjogUGFzc2VuZ2VyW10gPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IHN0YXJ0TG9jYXRpb247XG5cbiAgICAgICAgd2hpbGUgKHVudmlzaXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgbmVhcmVzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0RGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbi5sYXQoKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50TG9jYXRpb24ubG5nKCksXG4gICAgICAgICAgICAgICAgdW52aXNpdGVkWzBdLnBvc2l0aW9uLmxhdCxcbiAgICAgICAgICAgICAgICB1bnZpc2l0ZWRbMF0ucG9zaXRpb24ubG5nXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBFbmNvbnRyYSBvIHBhc3NhZ2Vpcm8gbWFpcyBwcsOzeGltb1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB1bnZpc2l0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbi5sYXQoKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLmxuZygpLFxuICAgICAgICAgICAgICAgICAgICB1bnZpc2l0ZWRbaV0ucG9zaXRpb24ubGF0LFxuICAgICAgICAgICAgICAgICAgICB1bnZpc2l0ZWRbaV0ucG9zaXRpb24ubG5nXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG5lYXJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkaWNpb25hIG8gcGFzc2FnZWlybyBtYWlzIHByw7N4aW1vIMOgIHJvdGEgb3RpbWl6YWRhXG4gICAgICAgICAgICBjb25zdCBuZWFyZXN0UGFzc2VuZ2VyID0gdW52aXNpdGVkLnNwbGljZShuZWFyZXN0SW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgb3B0aW1pemVkT3JkZXIucHVzaChuZWFyZXN0UGFzc2VuZ2VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbiA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoXG4gICAgICAgICAgICAgICAgbmVhcmVzdFBhc3Nlbmdlci5wb3NpdGlvbi5sYXQsXG4gICAgICAgICAgICAgICAgbmVhcmVzdFBhc3Nlbmdlci5wb3NpdGlvbi5sbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW1pemVkT3JkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxnb3JpdG1vIDItb3B0IHBhcmEgbWVsaG9yYXIgYSByb3RhIGV4aXN0ZW50ZVxuICAgICAqL1xuICAgIHByaXZhdGUgdHdvT3B0SW1wcm92ZW1lbnQoXG4gICAgICAgIHN0YXJ0TG9jYXRpb246IGdvb2dsZS5tYXBzLkxhdExuZyxcbiAgICAgICAgcm91dGU6IFBhc3NlbmdlcltdLFxuICAgICAgICBkZXN0aW5hdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nXG4gICAgKTogUGFzc2VuZ2VyW10ge1xuICAgICAgICBsZXQgaW1wcm92ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgYmVzdFJvdXRlID0gWy4uLnJvdXRlXTtcbiAgICAgICAgbGV0IGJlc3REaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlVG90YWxSb3V0ZURpc3RhbmNlKHN0YXJ0TG9jYXRpb24sIGJlc3RSb3V0ZSwgZGVzdGluYXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpbXByb3ZlZCkge1xuICAgICAgICAgICAgaW1wcm92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3V0ZS5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCByb3V0ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiAtIGkgPT09IDEpIGNvbnRpbnVlOyAvLyBTa2lwIGFkamFjZW50IGVkZ2VzXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBDcmlhIG5vdmEgcm90YSBjb20gMi1vcHQgc3dhcFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSb3V0ZSA9IHRoaXMudHdvT3B0U3dhcChyb3V0ZSwgaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVUb3RhbFJvdXRlRGlzdGFuY2Uoc3RhcnRMb2NhdGlvbiwgbmV3Um91dGUsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFJvdXRlID0gbmV3Um91dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlID0gbmV3Um91dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbXByb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmVzdFJvdXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGEgbyBzd2FwIDItb3B0XG4gICAgICovXG4gICAgcHJpdmF0ZSB0d29PcHRTd2FwKHJvdXRlOiBQYXNzZW5nZXJbXSwgaTogbnVtYmVyLCBqOiBudW1iZXIpOiBQYXNzZW5nZXJbXSB7XG4gICAgICAgIGNvbnN0IG5ld1JvdXRlID0gWy4uLnJvdXRlXTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJldmVydGUgYSBvcmRlbSBkb3MgZWxlbWVudG9zIGVudHJlIGkgZSBqXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgW25ld1JvdXRlW2ldLCBuZXdSb3V0ZVtqXV0gPSBbbmV3Um91dGVbal0sIG5ld1JvdXRlW2ldXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ld1JvdXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGEgYSBkaXN0w6JuY2lhIHRvdGFsIGRlIHVtYSByb3RhXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVUb3RhbFJvdXRlRGlzdGFuY2UoXG4gICAgICAgIHN0YXJ0TG9jYXRpb246IGdvb2dsZS5tYXBzLkxhdExuZyxcbiAgICAgICAgcm91dGU6IFBhc3NlbmdlcltdLFxuICAgICAgICBkZXN0aW5hdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nXG4gICAgKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHRvdGFsRGlzdGFuY2UgPSAwO1xuICAgICAgICBsZXQgY3VycmVudExvY2F0aW9uID0gc3RhcnRMb2NhdGlvbjtcblxuICAgICAgICAvLyBEaXN0w6JuY2lhIGRvIGluw61jaW8gYXTDqSBvIHByaW1laXJvIHBhc3NhZ2Vpcm9cbiAgICAgICAgaWYgKHJvdXRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShcbiAgICAgICAgICAgICAgICBjdXJyZW50TG9jYXRpb24ubGF0KCksXG4gICAgICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLmxuZygpLFxuICAgICAgICAgICAgICAgIHJvdXRlWzBdLnBvc2l0aW9uLmxhdCxcbiAgICAgICAgICAgICAgICByb3V0ZVswXS5wb3NpdGlvbi5sbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXN0w6JuY2lhIGVudHJlIHBhc3NhZ2Vpcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgcm91dGVbaV0ucG9zaXRpb24ubGF0LFxuICAgICAgICAgICAgICAgIHJvdXRlW2ldLnBvc2l0aW9uLmxuZyxcbiAgICAgICAgICAgICAgICByb3V0ZVtpICsgMV0ucG9zaXRpb24ubGF0LFxuICAgICAgICAgICAgICAgIHJvdXRlW2kgKyAxXS5wb3NpdGlvbi5sbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXN0w6JuY2lhIGRvIMO6bHRpbW8gcGFzc2FnZWlybyBhdMOpIG8gZGVzdGlub1xuICAgICAgICBpZiAocm91dGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKFxuICAgICAgICAgICAgICAgIHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdLnBvc2l0aW9uLmxhdCxcbiAgICAgICAgICAgICAgICByb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXS5wb3NpdGlvbi5sbmcsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubGF0KCksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24ubG5nKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG90YWxEaXN0YW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhIGhvcsOhcmlvcyBlc3RpbWFkb3MgZGUgY29sZXRhIGJhc2VhZG9zIG5hIHJvdGEgb3RpbWl6YWRhXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVQaWNrdXBUaW1lcyhcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nLFxuICAgICAgICBvcHRpbWl6ZWRQYXNzZW5nZXJzOiBQYXNzZW5nZXJbXSxcbiAgICAgICAgc3RhcnRUaW1lOiBEYXRlID0gbmV3IERhdGUoKVxuICAgICk6IHsgcGFzc2VuZ2VyOiBQYXNzZW5nZXI7IGVzdGltYXRlZFBpY2t1cFRpbWU6IERhdGUgfVtdIHtcbiAgICAgICAgY29uc3QgcGlja3VwVGltZXM6IHsgcGFzc2VuZ2VyOiBQYXNzZW5nZXI7IGVzdGltYXRlZFBpY2t1cFRpbWU6IERhdGUgfVtdID0gW107XG4gICAgICAgIGxldCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKHN0YXJ0VGltZSk7XG4gICAgICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGFydExvY2F0aW9uO1xuXG4gICAgICAgIC8vIFZlbG9jaWRhZGUgbcOpZGlhIGVzdGltYWRhIChrbS9oKSAtIHBvZGUgc2VyIGNvbmZpZ3Vyw6F2ZWxcbiAgICAgICAgY29uc3QgYXZlcmFnZVNwZWVkID0gMzA7IC8vIDMwIGttL2ggZW0gw6FyZWEgdXJiYW5hXG4gICAgICAgIGNvbnN0IHN0b3BUaW1lID0gMjsgLy8gMiBtaW51dG9zIHBvciBwYXJhZGFcblxuICAgICAgICBmb3IgKGNvbnN0IHBhc3NlbmdlciBvZiBvcHRpbWl6ZWRQYXNzZW5nZXJzKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhIGRpc3TDom5jaWEgYXTDqSBvIHBhc3NhZ2Vpcm9cbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShcbiAgICAgICAgICAgICAgICBjdXJyZW50TG9jYXRpb24ubGF0KCksXG4gICAgICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLmxuZygpLFxuICAgICAgICAgICAgICAgIHBhc3Nlbmdlci5wb3NpdGlvbi5sYXQsXG4gICAgICAgICAgICAgICAgcGFzc2VuZ2VyLnBvc2l0aW9uLmxuZ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYSB0ZW1wbyBkZSB2aWFnZW0gZW0gbWludXRvc1xuICAgICAgICAgICAgY29uc3QgdHJhdmVsVGltZU1pbnV0ZXMgPSAoZGlzdGFuY2UgLyBhdmVyYWdlU3BlZWQpICogNjA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkaWNpb25hIHRlbXBvIGRlIHZpYWdlbSBhbyB0ZW1wbyBhdHVhbFxuICAgICAgICAgICAgY3VycmVudFRpbWUgPSBuZXcgRGF0ZShjdXJyZW50VGltZS5nZXRUaW1lKCkgKyB0cmF2ZWxUaW1lTWludXRlcyAqIDYwMDAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGlja3VwVGltZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcGFzc2VuZ2VyLFxuICAgICAgICAgICAgICAgIGVzdGltYXRlZFBpY2t1cFRpbWU6IG5ldyBEYXRlKGN1cnJlbnRUaW1lKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEFkaWNpb25hIHRlbXBvIGRlIHBhcmFkYVxuICAgICAgICAgICAgY3VycmVudFRpbWUgPSBuZXcgRGF0ZShjdXJyZW50VGltZS5nZXRUaW1lKCkgKyBzdG9wVGltZSAqIDYwMDAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXR1YWxpemEgbG9jYWxpemHDp8OjbyBhdHVhbFxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhcbiAgICAgICAgICAgICAgICBwYXNzZW5nZXIucG9zaXRpb24ubGF0LFxuICAgICAgICAgICAgICAgIHBhc3Nlbmdlci5wb3NpdGlvbi5sbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGlja3VwVGltZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYSBhIHJvdGEgb3RpbWl6YWRhIHVzYW5kbyBHb29nbGUgRGlyZWN0aW9ucyBBUElcbiAgICAgKi9cbiAgICBhc3luYyBjYWxjdWxhdGVPcHRpbWl6ZWRSb3V0ZShvcHRpb25zOiBSb3V0ZU9wdGltaXphdGlvbk9wdGlvbnMpOiBQcm9taXNlPE9wdGltaXplZFJvdXRlPiB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRMb2NhdGlvbiwgcGFzc2VuZ2VycywgZGVzdGluYXRpb24sIG9wdGltaXplT3JkZXIgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFZlcmlmaWNhIGNhY2hlIHByaW1laXJvXG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0Q2FjaGVLZXkob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3V0ZUNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRSb3V0ZSA9IHRoaXMucm91dGVDYWNoZS5nZXQoY2FjaGVLZXkpITtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUm90YSBlbmNvbnRyYWRhIG5vIGNhY2hlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJvdXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZ3VhcmRhIGEgaW5pY2lhbGl6YcOnw6NvIGRvIHNlcnZpw6dvIHNlIG5lY2Vzc8OhcmlvXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlyZWN0aW9uc1NlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVTZXJ2aWNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5kaXJlY3Rpb25zU2VydmljZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ0dvb2dsZSBNYXBzIEFQSSBuw6NvIGVzdMOhIGNhcnJlZ2FkYScpIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ0dPT0dMRV9NQVBTX05PVF9MT0FERUQnO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWYWxpZGHDp8OjbyBkb3MgcGFyw6JtZXRyb3MgZGUgZW50cmFkYVxuICAgICAgICAgICAgaWYgKCFzdGFydExvY2F0aW9uIHx8ICFkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ0Nvb3JkZW5hZGFzIGRlIGluw61jaW8gb3UgZGVzdGlubyBuw6NvIGZvcm5lY2lkYXMnKSBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdJTlZBTElEX0NPT1JESU5BVEVTJztcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVmFsaWRhw6fDo28gZXNwZWPDrWZpY2EgcGFyYSBvYmpldG9zIExhdExuZ1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExhdCA9IHR5cGVvZiBzdGFydExvY2F0aW9uLmxhdCA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXJ0TG9jYXRpb24ubGF0KCkgOiAoc3RhcnRMb2NhdGlvbiBhcyBhbnkpLmxhdDtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExuZyA9IHR5cGVvZiBzdGFydExvY2F0aW9uLmxuZyA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXJ0TG9jYXRpb24ubG5nKCkgOiAoc3RhcnRMb2NhdGlvbiBhcyBhbnkpLmxuZztcbiAgICAgICAgICAgICAgICBjb25zdCBkZXN0TGF0ID0gdHlwZW9mIGRlc3RpbmF0aW9uLmxhdCA9PT0gJ2Z1bmN0aW9uJyA/IGRlc3RpbmF0aW9uLmxhdCgpIDogKGRlc3RpbmF0aW9uIGFzIGFueSkubGF0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RMbmcgPSB0eXBlb2YgZGVzdGluYXRpb24ubG5nID09PSAnZnVuY3Rpb24nID8gZGVzdGluYXRpb24ubG5nKCkgOiAoZGVzdGluYXRpb24gYXMgYW55KS5sbmc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGFydExhdCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHN0YXJ0TG5nICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZGVzdExhdCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRlc3RMbmcgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzTmFOKHN0YXJ0TGF0KSB8fCBpc05hTihzdGFydExuZykgfHwgaXNOYU4oZGVzdExhdCkgfHwgaXNOYU4oZGVzdExuZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3I6IFJvdXRlQ2FsY3VsYXRpb25FcnJvciA9IG5ldyBFcnJvcignQ29vcmRlbmFkYXMgZGUgaW7DrWNpbyBvdSBkZXN0aW5vIHPDo28gaW52w6FsaWRhcycpIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdJTlZBTElEX0NPT1JESU5BVEVTJztcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGV0YWlscyA9IGBTdGFydDogJHtzdGFydExhdH0sICR7c3RhcnRMbmd9IHwgRGVzdDogJHtkZXN0TGF0fSwgJHtkZXN0TG5nfWA7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVFcnJvcjogUm91dGVDYWxjdWxhdGlvbkVycm9yID0gbmV3IEVycm9yKGBFcnJvIGFvIHZhbGlkYXIgY29vcmRlbmFkYXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRXJybyBkZXNjb25oZWNpZG8nfWApIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICByb3V0ZUVycm9yLmNvZGUgPSAnSU5WQUxJRF9DT09SRElOQVRFUyc7XG4gICAgICAgICAgICAgICAgdGhyb3cgcm91dGVFcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFwYXNzZW5nZXJzIHx8IHBhc3NlbmdlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3I6IFJvdXRlQ2FsY3VsYXRpb25FcnJvciA9IG5ldyBFcnJvcignTGlzdGEgZGUgcGFzc2FnZWlyb3MgbsOjbyBmb3JuZWNpZGEgb3UgdmF6aWEnKSBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdOT19QQVNTRU5HRVJTJztcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoZXJyb3IgYXMgUm91dGVDYWxjdWxhdGlvbkVycm9yKS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoYEVycm8gaW5lc3BlcmFkbyBuYSB2YWxpZGHDp8OjbyBpbmljaWFsOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Vycm8gZGVzY29uaGVjaWRvJ31gKSBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICByb3V0ZUVycm9yLmNvZGUgPSAnVU5LTk9XTl9FUlJPUic7XG4gICAgICAgICAgICB0aHJvdyByb3V0ZUVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhIGNvb3JkZW5hZGFzIGRlIHRvZG9zIG9zIHBhc3NhZ2Vpcm9zXG4gICAgICAgIGZvciAoY29uc3QgcGFzc2VuZ2VyIG9mIHBhc3NlbmdlcnMpIHtcbiAgICAgICAgICAgIGlmICghcGFzc2VuZ2VyLnBvc2l0aW9uIHx8IFxuICAgICAgICAgICAgICAgIHR5cGVvZiBwYXNzZW5nZXIucG9zaXRpb24ubGF0ICE9PSAnbnVtYmVyJyB8fCBcbiAgICAgICAgICAgICAgICB0eXBlb2YgcGFzc2VuZ2VyLnBvc2l0aW9uLmxuZyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICBpc05hTihwYXNzZW5nZXIucG9zaXRpb24ubGF0KSB8fCBcbiAgICAgICAgICAgICAgICBpc05hTihwYXNzZW5nZXIucG9zaXRpb24ubG5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoYENvb3JkZW5hZGFzIGludsOhbGlkYXMgcGFyYSBvIHBhc3NhZ2Vpcm8gJHtwYXNzZW5nZXIubmFtZSB8fCAnZGVzY29uaGVjaWRvJ31gKSBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdJTlZBTElEX0NPT1JESU5BVEVTJztcbiAgICAgICAgICAgICAgICBlcnJvci5kZXRhaWxzID0gYFBhc3NhZ2Vpcm86ICR7cGFzc2VuZ2VyLm5hbWV9LCBQb3Npw6fDo286ICR7SlNPTi5zdHJpbmdpZnkocGFzc2VuZ2VyLnBvc2l0aW9uKX1gO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RpbWl6YSBhIG9yZGVtIGRvcyBwYXNzYWdlaXJvcyBzZSBzb2xpY2l0YWRvXG4gICAgICAgIGNvbnN0IG9yZGVyZWRQYXNzZW5nZXJzID0gb3B0aW1pemVPcmRlciBcbiAgICAgICAgICAgID8gdGhpcy5vcHRpbWl6ZVBhc3Nlbmdlck9yZGVyKHN0YXJ0TG9jYXRpb24sIHBhc3NlbmdlcnMsIGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgOiBwYXNzZW5nZXJzO1xuXG4gICAgICAgIC8vIFByZXBhcmEgb3Mgd2F5cG9pbnRzIHBhcmEgYSBBUEkgZG8gR29vZ2xlXG4gICAgICAgIGNvbnN0IHdheXBvaW50cyA9IG9yZGVyZWRQYXNzZW5nZXJzLm1hcChwYXNzZW5nZXIgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBWYWxpZGHDp8OjbyBhZGljaW9uYWwgYW50ZXMgZGUgY3JpYXIgTGF0TG5nXG4gICAgICAgICAgICAgICAgaWYgKCFwYXNzZW5nZXIucG9zaXRpb24gfHwgXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwYXNzZW5nZXIucG9zaXRpb24ubGF0ICE9PSAnbnVtYmVyJyB8fCBcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBhc3Nlbmdlci5wb3NpdGlvbi5sbmcgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzTmFOKHBhc3Nlbmdlci5wb3NpdGlvbi5sYXQpIHx8IFxuICAgICAgICAgICAgICAgICAgICBpc05hTihwYXNzZW5nZXIucG9zaXRpb24ubG5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvb3JkZW5hZGFzIGludsOhbGlkYXMgcGFyYSBwYXNzYWdlaXJvICR7cGFzc2VuZ2VyLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHBhc3Nlbmdlci5wb3NpdGlvbi5sYXQsIHBhc3Nlbmdlci5wb3NpdGlvbi5sbmcpLFxuICAgICAgICAgICAgICAgICAgICBzdG9wb3ZlcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm8gYW8gY3JpYXIgd2F5cG9pbnQgcGFyYSBwYXNzYWdlaXJvICR7cGFzc2VuZ2VyLm5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPE9wdGltaXplZFJvdXRlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3Q6IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHN0YXJ0TG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgd2F5cG9pbnRzOiB3YXlwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlbE1vZGU6IGdvb2dsZS5tYXBzLlRyYXZlbE1vZGUuRFJJVklORyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pemVXYXlwb2ludHM6IGZhbHNlIC8vIFVzYW1vcyBub3NzYSBwcsOzcHJpYSBvdGltaXphw6fDo29cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25zU2VydmljZSEucm91dGUocmVxdWVzdCwgKGRpcmVjdGlvbnNSZXN1bHQsIHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gZ29vZ2xlLm1hcHMuRGlyZWN0aW9uc1N0YXR1cy5PSyAmJiBkaXJlY3Rpb25zUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gZGlyZWN0aW9uc1Jlc3VsdC5yb3V0ZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlZyA9IHJvdXRlLmxlZ3M7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhIGRpc3TDom5jaWEgZSBkdXJhw6fDo28gdG90YWxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsRGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZWcuZm9yRWFjaChzZWdtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LmRpc3RhbmNlKSB0b3RhbERpc3RhbmNlICs9IHNlZ21lbnQuZGlzdGFuY2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5kdXJhdGlvbikgdG90YWxEdXJhdGlvbiArPSBzZWdtZW50LmR1cmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWkgbyBjYW1pbmhvIGRhIHBvbHlsaW5lIGNvbSB2YWxpZGHDp8Ojb1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5bGluZVBhdGg6IGdvb2dsZS5tYXBzLkxhdExuZ1tdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZS5vdmVydmlld19wYXRoICYmIEFycmF5LmlzQXJyYXkocm91dGUub3ZlcnZpZXdfcGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlLm92ZXJ2aWV3X3BhdGguZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhIHNlIG8gcG9udG8gdGVtIGNvb3JkZW5hZGFzIHbDoWxpZGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhdCA9IHR5cGVvZiBwb2ludC5sYXQgPT09ICdmdW5jdGlvbicgPyBwb2ludC5sYXQoKSA6IHBvaW50LmxhdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG5nID0gdHlwZW9mIHBvaW50LmxuZyA9PT0gJ2Z1bmN0aW9uJyA/IHBvaW50LmxuZygpIDogcG9pbnQubG5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXQgPT09ICdudW1iZXInICYmIHR5cGVvZiBsbmcgPT09ICdudW1iZXInICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzTmFOKGxhdCkgJiYgIWlzTmFOKGxuZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lUGF0aC5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRXJybyBhbyBwcm9jZXNzYXIgcG9udG8gZG8gcG9seWxpbmU6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JpYSBvcyB3YXlwb2ludHMgb3JkZW5hZG9zIGNvbSB2YWxpZGHDp8Ojb1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpbWl6ZWRXYXlwb2ludHM6IGdvb2dsZS5tYXBzLkxhdExuZ1tdID0gW3N0YXJ0TG9jYXRpb24gYXMgZ29vZ2xlLm1hcHMuTGF0TG5nXTtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZFBhc3NlbmdlcnMuZm9yRWFjaChwYXNzZW5nZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFzc2VuZ2VyLnBvc2l0aW9uICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGFzc2VuZ2VyLnBvc2l0aW9uLmxhdCA9PT0gJ251bWJlcicgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwYXNzZW5nZXIucG9zaXRpb24ubG5nID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNOYU4ocGFzc2VuZ2VyLnBvc2l0aW9uLmxhdCkgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc05hTihwYXNzZW5nZXIucG9zaXRpb24ubG5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpbWl6ZWRXYXlwb2ludHMucHVzaChuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VuZ2VyLnBvc2l0aW9uLmxhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3Nlbmdlci5wb3NpdGlvbi5sbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm8gYW8gY3JpYXIgd2F5cG9pbnQgcGFyYSBwYXNzYWdlaXJvICR7cGFzc2VuZ2VyLm5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGltaXplZFdheXBvaW50cy5wdXNoKGRlc3RpbmF0aW9uIGFzIGdvb2dsZS5tYXBzLkxhdExuZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYSBob3LDoXJpb3MgZXN0aW1hZG9zIGRlIHBpY2t1cFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWNrdXBUaW1lcyA9IHRoaXMuY2FsY3VsYXRlUGlja3VwVGltZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZFBhc3NlbmdlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQ6IE9wdGltaXplZFJvdXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXlwb2ludHM6IG9wdGltaXplZFdheXBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZFBhc3NlbmdlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRGlzdGFuY2U6IHRvdGFsRGlzdGFuY2UgLyAxMDAwLCAvLyBDb252ZXJ0ZSBwYXJhIGttXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRHVyYXRpb246IHRvdGFsRHVyYXRpb24gLyA2MCwgLy8gQ29udmVydGUgcGFyYSBtaW51dG9zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlja3VwVGltZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJtYXplbmEgbm8gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0IGFzIGFueSkudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0Q2FjaGVLZXkob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3V0ZUNhY2hlLnNldChjYWNoZUtleSwgcmVzdWx0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3I6IFJvdXRlQ2FsY3VsYXRpb25FcnJvciA9IG5ldyBFcnJvcihgRmFsaGEgYW8gY2FsY3VsYXIgcm90YTogJHtzdGF0dXN9YCkgYXMgUm91dGVDYWxjdWxhdGlvbkVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSAnRElSRUNUSU9OU19BUElfRVJST1InO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmRldGFpbHMgPSBgU3RhdHVzOiAke3N0YXR1c31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZUVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoYEVycm8gYW8gcHJvY2Vzc2FyIHJlc3VsdGFkbyBkYSByb3RhOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Vycm8gZGVzY29uaGVjaWRvJ31gKSBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUVycm9yLmNvZGUgPSAnVU5LTk9XTl9FUlJPUic7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qocm91dGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVFcnJvcjogUm91dGVDYWxjdWxhdGlvbkVycm9yID0gbmV3IEVycm9yKGBFcnJvIGFvIGNyaWFyIHJlcXVpc2nDp8OjbyBkZSByb3RhOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0Vycm8gZGVzY29uaGVjaWRvJ31gKSBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgcm91dGVFcnJvci5jb2RlID0gJ1VOS05PV05fRVJST1InO1xuICAgICAgICAgICAgICAgIHJlamVjdChyb3V0ZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb250cmEgYSBtZWxob3Igcm90YSBwb3Nzw612ZWwsIGNvbSBmYWxsYmFjayBwYXJhIHJvdGEgbsOjbyBvdGltaXphZGFcbiAgICAgKi9cbiAgICBhc3luYyBmaW5kQmVzdFJvdXRlKG9wdGlvbnM6IFJvdXRlT3B0aW1pemF0aW9uT3B0aW9ucyk6IFByb21pc2U8T3B0aW1pemVkUm91dGU+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEFndWFyZGEgYSBpbmljaWFsaXphw6fDo28gZG8gc2VydmnDp28gc2UgbmVjZXNzw6FyaW9cbiAgICAgICAgICAgIGlmICghdGhpcy5kaXJlY3Rpb25zU2VydmljZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVNlcnZpY2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGVudGEgY2FsY3VsYXIgcm90YSBvdGltaXphZGFcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNhbGN1bGF0ZU9wdGltaXplZFJvdXRlKG9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvIGFvIGNhbGN1bGFyIHJvdGEgb3RpbWl6YWRhOicsIGVycm9yKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRmFsbGJhY2s6IHJvdGEgc2VtIG90aW1pemHDp8Ojb1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jYWxjdWxhdGVPcHRpbWl6ZWRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9wdGltaXplT3JkZXI6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBjYWxjdWxhciByb3RhIGRlIGZhbGxiYWNrOicsIGZhbGxiYWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFNlIGFpbmRhIGFzc2ltIGZhbGhhciwgcmV0b3JuYSB1bWEgcm90YSBiw6FzaWNhIGNvbSBkYWRvcyBlc3RpbWFkb3NcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWxsYmFja1JvdXRlKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JpYSB1bWEgcm90YSBkZSBmYWxsYmFjayBjb20gZGFkb3MgZXN0aW1hZG9zIHF1YW5kbyBhIEFQSSBmYWxoYVxuICAgICAqL1xuICAgIHByaXZhdGUgY3JlYXRlRmFsbGJhY2tSb3V0ZShvcHRpb25zOiBSb3V0ZU9wdGltaXphdGlvbk9wdGlvbnMpOiBPcHRpbWl6ZWRSb3V0ZSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRMb2NhdGlvbiwgcGFzc2VuZ2VycywgZGVzdGluYXRpb24gfSA9IG9wdGlvbnM7XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGHDp8OjbyBlIGNvbnZlcnPDo28gZGUgY29vcmRlbmFkYXMgcGFyYSBmb3JtYXRvIHNpbXBsZXNcbiAgICAgICAgaWYgKCFzdGFydExvY2F0aW9uIHx8ICFkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29yZGVuYWRhcyBkZSBpbsOtY2lvIG91IGRlc3Rpbm8gbsOjbyBmb3JuZWNpZGFzJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN0YXJ0Q29vcmRzID0ge1xuICAgICAgICAgICAgbGF0OiB0eXBlb2Ygc3RhcnRMb2NhdGlvbi5sYXQgPT09ICdmdW5jdGlvbicgPyBzdGFydExvY2F0aW9uLmxhdCgpIDogc3RhcnRMb2NhdGlvbi5sYXQsXG4gICAgICAgICAgICBsbmc6IHR5cGVvZiBzdGFydExvY2F0aW9uLmxuZyA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXJ0TG9jYXRpb24ubG5nKCkgOiBzdGFydExvY2F0aW9uLmxuZ1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZGVzdENvb3JkcyA9IHtcbiAgICAgICAgICAgIGxhdDogdHlwZW9mIGRlc3RpbmF0aW9uLmxhdCA9PT0gJ2Z1bmN0aW9uJyA/IGRlc3RpbmF0aW9uLmxhdCgpIDogZGVzdGluYXRpb24ubGF0LFxuICAgICAgICAgICAgbG5nOiB0eXBlb2YgZGVzdGluYXRpb24ubG5nID09PSAnZnVuY3Rpb24nID8gZGVzdGluYXRpb24ubG5nKCkgOiBkZXN0aW5hdGlvbi5sbmdcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYcOnw6NvIGRhcyBjb29yZGVuYWRhcyBjb252ZXJ0aWRhc1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0Q29vcmRzLmxhdCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHN0YXJ0Q29vcmRzLmxuZyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHR5cGVvZiBkZXN0Q29vcmRzLmxhdCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRlc3RDb29yZHMubG5nICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29yZGVuYWRhcyBpbnbDoWxpZGFzIGZvcm5lY2lkYXMnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhw6fDo28gZG9zIHBhc3NhZ2Vpcm9zIGUgc3VhcyBjb29yZGVuYWRhc1xuICAgICAgICBpZiAoIXBhc3NlbmdlcnMgfHwgcGFzc2VuZ2Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGlzdGEgZGUgcGFzc2FnZWlyb3MgbsOjbyBmb3JuZWNpZGEgb3UgdmF6aWEnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhIGNvb3JkZW5hZGFzIGRlIHRvZG9zIG9zIHBhc3NhZ2Vpcm9zXG4gICAgICAgIGZvciAoY29uc3QgcGFzc2VuZ2VyIG9mIHBhc3NlbmdlcnMpIHtcbiAgICAgICAgICAgIGlmICghcGFzc2VuZ2VyLnBvc2l0aW9uIHx8IFxuICAgICAgICAgICAgICAgIHR5cGVvZiBwYXNzZW5nZXIucG9zaXRpb24ubGF0ICE9PSAnbnVtYmVyJyB8fCBcbiAgICAgICAgICAgICAgICB0eXBlb2YgcGFzc2VuZ2VyLnBvc2l0aW9uLmxuZyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvb3JkZW5hZGFzIGludsOhbGlkYXMgcGFyYSBvIHBhc3NhZ2Vpcm8gJHtwYXNzZW5nZXIubmFtZSB8fCAnZGVzY29uaGVjaWRvJ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYSBkaXN0w6JuY2lhcyBlc3RpbWFkYXMgdXNhbmRvIEhhdmVyc2luZVxuICAgICAgICBsZXQgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50Q29vcmRzID0gc3RhcnRDb29yZHM7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGNvbnN0IHBhc3NlbmdlciBvZiBwYXNzZW5nZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGF0ID0gdHlwZW9mIGN1cnJlbnRDb29yZHMubGF0ID09PSAnZnVuY3Rpb24nID8gY3VycmVudENvb3Jkcy5sYXQoKSA6IGN1cnJlbnRDb29yZHMubGF0O1xuICAgICAgICAgICAgY29uc3QgY3VycmVudExuZyA9IHR5cGVvZiBjdXJyZW50Q29vcmRzLmxuZyA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnRDb29yZHMubG5nKCkgOiBjdXJyZW50Q29vcmRzLmxuZztcbiAgICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShcbiAgICAgICAgICAgICAgICBjdXJyZW50TGF0LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMbmcsXG4gICAgICAgICAgICAgICAgcGFzc2VuZ2VyLnBvc2l0aW9uLmxhdCxcbiAgICAgICAgICAgICAgICBwYXNzZW5nZXIucG9zaXRpb24ubG5nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudENvb3JkcyA9IHBhc3Nlbmdlci5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRpY2lvbmEgZGlzdMOibmNpYSBhdMOpIG8gZGVzdGlub1xuICAgICAgICBjb25zdCBmaW5hbExhdCA9IHR5cGVvZiBjdXJyZW50Q29vcmRzLmxhdCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnRDb29yZHMubGF0KCkgOiBjdXJyZW50Q29vcmRzLmxhdDtcbiAgICAgICAgY29uc3QgZmluYWxMbmcgPSB0eXBlb2YgY3VycmVudENvb3Jkcy5sbmcgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50Q29vcmRzLmxuZygpIDogY3VycmVudENvb3Jkcy5sbmc7XG4gICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShcbiAgICAgICAgICAgIGZpbmFsTGF0LFxuICAgICAgICAgICAgZmluYWxMbmcsXG4gICAgICAgICAgICBkZXN0Q29vcmRzLmxhdCxcbiAgICAgICAgICAgIGRlc3RDb29yZHMubG5nXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBFc3RpbWEgZHVyYcOnw6NvIChhc3N1bWluZG8gdmVsb2NpZGFkZSBtw6lkaWEgZGUgMzAga20vaCBubyB0csOibnNpdG8gdXJiYW5vKVxuICAgICAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gKHRvdGFsRGlzdGFuY2UgLyAzMCkgKiA2MDsgLy8gZW0gbWludXRvc1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYSBob3LDoXJpb3MgZXN0aW1hZG9zIHNpbXBsaWZpY2Fkb3MgcGFyYSBmYWxsYmFja1xuICAgICAgICBjb25zdCBwaWNrdXBUaW1lczogeyBwYXNzZW5nZXI6IFBhc3NlbmdlcjsgZXN0aW1hdGVkUGlja3VwVGltZTogRGF0ZSB9W10gPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoc3RhcnRUaW1lKTtcbiAgICAgICAgXG4gICAgICAgIHBhc3NlbmdlcnMuZm9yRWFjaCgocGFzc2VuZ2VyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gQWRpY2lvbmEgdGVtcG8gZXN0aW1hZG8gYmFzZWFkbyBuYSBkaXN0w6JuY2lhXG4gICAgICAgICAgICBjb25zdCB0aW1lVG9QYXNzZW5nZXIgPSAoaW5kZXggKyAxKSAqICh0b3RhbER1cmF0aW9uIC8gcGFzc2VuZ2Vycy5sZW5ndGgpO1xuICAgICAgICAgICAgY3VycmVudFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWUuZ2V0VGltZSgpICsgdGltZVRvUGFzc2VuZ2VyICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGlja3VwVGltZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcGFzc2VuZ2VyLFxuICAgICAgICAgICAgICAgIGVzdGltYXRlZFBpY2t1cFRpbWU6IG5ldyBEYXRlKGN1cnJlbnRUaW1lKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JpYSB3YXlwb2ludHMgYsOhc2ljb3MgcGFyYSBmYWxsYmFja1xuICAgICAgICBjb25zdCBmYWxsYmFja1dheXBvaW50czogZ29vZ2xlLm1hcHMuTGF0TG5nW10gPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZhbGxiYWNrV2F5cG9pbnRzLnB1c2gobmV3IGdvb2dsZS5tYXBzLkxhdExuZyhzdGFydENvb3Jkcy5sYXQsIHN0YXJ0Q29vcmRzLmxuZykpO1xuICAgICAgICAgICAgcGFzc2VuZ2Vycy5mb3JFYWNoKHBhc3NlbmdlciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3Nlbmdlci5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja1dheXBvaW50cy5wdXNoKG5ldyBnb29nbGUubWFwcy5MYXRMbmcocGFzc2VuZ2VyLnBvc2l0aW9uLmxhdCwgcGFzc2VuZ2VyLnBvc2l0aW9uLmxuZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmFsbGJhY2tXYXlwb2ludHMucHVzaChuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGRlc3RDb29yZHMubGF0LCBkZXN0Q29vcmRzLmxuZykpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvIGFvIGNyaWFyIHdheXBvaW50cyBkZSBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2F5cG9pbnRzOiBmYWxsYmFja1dheXBvaW50cyxcbiAgICAgICAgICAgIG9yZGVyZWRQYXNzZW5nZXJzOiBwYXNzZW5nZXJzLFxuICAgICAgICAgICAgdG90YWxEaXN0YW5jZSxcbiAgICAgICAgICAgIHRvdGFsRHVyYXRpb24sXG4gICAgICAgICAgICBwb2x5bGluZVBhdGg6IFtdLCAvLyBTZW0gcG9seWxpbmUgcGFyYSByb3RhIGRlIGZhbGxiYWNrXG4gICAgICAgICAgICBwaWNrdXBUaW1lc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzdGltYSBvIHRlbXBvIGRlIGVtYmFycXVlIGJhc2VhZG8gbm8gbsO6bWVybyBkZSBwYXNzYWdlaXJvc1xuICAgICAqL1xuICAgIGVzdGltYXRlQm9hcmRpbmdUaW1lKHBhc3NlbmdlckNvdW50OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBFc3RpbWEgMzAgc2VndW5kb3MgcG9yIHBhc3NhZ2Vpcm8gKyAxIG1pbnV0byBiYXNlXG4gICAgICAgIHJldHVybiAxICsgKHBhc3NlbmdlckNvdW50ICogMC41KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhIG8gaG9yw6FyaW8gZXN0aW1hZG8gZGUgY2hlZ2FkYSBwYXJhIGNhZGEgcGFzc2FnZWlybyAobcOpdG9kbyBhbHRlcm5hdGl2byBwYXJhIGNvbXBhdGliaWxpZGFkZSlcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVQaWNrdXBUaW1lc0Zyb21TZWdtZW50cyhcbiAgICAgICAgc3RhcnRUaW1lOiBEYXRlLFxuICAgICAgICBvcmRlcmVkUGFzc2VuZ2VyczogUGFzc2VuZ2VyW10sXG4gICAgICAgIHJvdXRlU2VnbWVudHM6IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNMZWdbXVxuICAgICk6IHsgcGFzc2VuZ2VyOiBQYXNzZW5nZXI7IGVzdGltYXRlZFBpY2t1cFRpbWU6IERhdGUgfVtdIHtcbiAgICAgICAgY29uc3QgcGlja3VwVGltZXM6IHsgcGFzc2VuZ2VyOiBQYXNzZW5nZXI7IGVzdGltYXRlZFBpY2t1cFRpbWU6IERhdGUgfVtdID0gW107XG4gICAgICAgIGxldCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKHN0YXJ0VGltZSk7XG5cbiAgICAgICAgb3JkZXJlZFBhc3NlbmdlcnMuZm9yRWFjaCgocGFzc2VuZ2VyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgcm91dGVTZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gcm91dGVTZWdtZW50c1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbWUgPSBuZXcgRGF0ZShjdXJyZW50VGltZS5nZXRUaW1lKCkgKyBzZWdtZW50LmR1cmF0aW9uLnZhbHVlICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwaWNrdXBUaW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXNzZW5nZXIsXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkUGlja3VwVGltZTogbmV3IERhdGUoY3VycmVudFRpbWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQWRpY2lvbmEgdGVtcG8gZGUgZW1iYXJxdWVcbiAgICAgICAgICAgIGNvbnN0IGJvYXJkaW5nVGltZSA9IHRoaXMuZXN0aW1hdGVCb2FyZGluZ1RpbWUoMSk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSA9IG5ldyBEYXRlKGN1cnJlbnRUaW1lLmdldFRpbWUoKSArIGJvYXJkaW5nVGltZSAqIDYwICogMTAwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwaWNrdXBUaW1lcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXJhIHN1Z2VzdMO1ZXMgZGUgb3RpbWl6YcOnw6NvIHBhcmEgdW1hIHJvdGFcbiAgICAgKi9cbiAgICBnZW5lcmF0ZU9wdGltaXphdGlvblN1Z2dlc3Rpb24ocGFzc2VuZ2VyQ291bnQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGlmIChwYXNzZW5nZXJDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiQWRpY2lvbmUgcGFzc2FnZWlyb3MgcGFyYSB2ZXIgc3VnZXN0w7VlcyBkZSBvdGltaXphw6fDo28uXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFzc2VuZ2VyQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIuKchSBSb3RhIHNpbXBsZXMgY29tIDEgcGFzc2FnZWlybyAtIHNlbSBuZWNlc3NpZGFkZSBkZSBvdGltaXphw6fDo28uXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFzc2VuZ2VyQ291bnQgPD0gMykge1xuICAgICAgICAgICAgcmV0dXJuIGDwn5qMIFJvdGEgY29tICR7cGFzc2VuZ2VyQ291bnR9IHBhc3NhZ2Vpcm9zIC0gb3RpbWl6YcOnw6NvIGF1dG9tw6F0aWNhIGFwbGljYWRhIHBhcmEgbWluaW1pemFyIGRpc3TDom5jaWEuYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXNzZW5nZXJDb3VudCA8PSA2KSB7XG4gICAgICAgICAgICByZXR1cm4gYPCfjq8gUm90YSBjb20gJHtwYXNzZW5nZXJDb3VudH0gcGFzc2FnZWlyb3MgLSBhbGdvcml0bW8gYXZhbsOnYWRvIGFwbGljYWRvIChOZWFyZXN0IE5laWdoYm9yICsgMi1vcHQpIHBhcmEgbcOheGltYSBlZmljacOqbmNpYS5gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGDimqEgUm90YSBjb21wbGV4YSBjb20gJHtwYXNzZW5nZXJDb3VudH0gcGFzc2FnZWlyb3MgLSBvdGltaXphw6fDo28gaW50ZWxpZ2VudGUgYXBsaWNhZGEuIFRlbXBvIGVzdGltYWRvIGRlIGVjb25vbWlhOiAke01hdGgucm91bmQocGFzc2VuZ2VyQ291bnQgKiAwLjgpfSBtaW51dG9zLmA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhIHNlIHVtIGVuZGVyZcOnbyB0ZW0gY29vcmRlbmFkYXMgdsOhbGlkYXNcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzczogc3RyaW5nLCBwb3NpdGlvbjogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIWFkZHJlc3MgfHwgYWRkcmVzcy50cmltKCkubGVuZ3RoIDwgMTApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcG9zaXRpb24gfHwgXG4gICAgICAgICAgICB0eXBlb2YgcG9zaXRpb24ubGF0ICE9PSAnbnVtYmVyJyB8fCBcbiAgICAgICAgICAgIHR5cGVvZiBwb3NpdGlvbi5sbmcgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBpc05hTihwb3NpdGlvbi5sYXQpIHx8IFxuICAgICAgICAgICAgaXNOYU4ocG9zaXRpb24ubG5nKSB8fFxuICAgICAgICAgICAgcG9zaXRpb24ubGF0ID09PSAwICYmIHBvc2l0aW9uLmxuZyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0YSB0ZW1wbyBlc3RpbWFkbyBkZSBjb2xldGFcbiAgICAgKi9cbiAgICBmb3JtYXRQaWNrdXBUaW1lKGVzdGltYXRlZFRpbWU6IERhdGUpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkaWZmTWludXRlcyA9IE1hdGgucm91bmQoKGVzdGltYXRlZFRpbWUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwKSk7XG5cbiAgICAgICAgaWYgKGRpZmZNaW51dGVzIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiSG9yw6FyaW8gcGFzc2Fkb1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpZmZNaW51dGVzIDwgNjApIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtkaWZmTWludXRlc30gbWluYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihkaWZmTWludXRlcyAvIDYwKTtcbiAgICAgICAgY29uc3QgbWludXRlcyA9IGRpZmZNaW51dGVzICUgNjA7XG4gICAgICAgIFxuICAgICAgICBpZiAoaG91cnMgPCAyNCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2hvdXJzfWgke21pbnV0ZXMgPiAwID8gYCAke21pbnV0ZXN9bWluYCA6ICcnfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXN0aW1hdGVkVGltZS50b0xvY2FsZURhdGVTdHJpbmcoJ3B0LUJSJywge1xuICAgICAgICAgICAgZGF5OiAnMi1kaWdpdCcsXG4gICAgICAgICAgICBtb250aDogJzItZGlnaXQnLFxuICAgICAgICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgICAgICAgbWludXRlOiAnMi1kaWdpdCdcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3Qgcm91dGVPcHRpbWl6YXRpb25TZXJ2aWNlID0gbmV3IFJvdXRlT3B0aW1pemF0aW9uU2VydmljZSgpOyJdLCJuYW1lcyI6WyJSb3V0ZU9wdGltaXphdGlvblNlcnZpY2UiLCJjbGVhckV4cGlyZWRDYWNoZSIsIm5vdyIsIkRhdGUiLCJrZXkiLCJ2YWx1ZSIsInJvdXRlQ2FjaGUiLCJlbnRyaWVzIiwidGltZXN0YW1wIiwiQ0FDSEVfRVhQSVJZIiwiZGVsZXRlIiwiZ2V0Q2FjaGVLZXkiLCJvcHRpb25zIiwic3RhcnRMb2NhdGlvbiIsInBhc3NlbmdlcnMiLCJkZXN0aW5hdGlvbiIsIm9wdGltaXplT3JkZXIiLCJzdGFydEtleSIsImxhdCIsImxuZyIsImRlc3RLZXkiLCJwYXNzZW5nZXJzS2V5IiwibWFwIiwicCIsImlkIiwicG9zaXRpb24iLCJzb3J0Iiwiam9pbiIsImluaXRpYWxpemVTZXJ2aWNlIiwid2luZG93Iiwid2FpdEZvckdvb2dsZU1hcHNBUEkiLCJnb29nbGUiLCJtYXBzIiwiRGlyZWN0aW9uc1NlcnZpY2UiLCJkaXJlY3Rpb25zU2VydmljZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ29vZ2xlTWFwc0FwaUxvYWRlZCIsImVycm9yIiwiRXJyb3IiLCJjb2RlIiwiYXR0ZW1wdHMiLCJtYXhBdHRlbXB0cyIsImNoZWNrSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJkZXRhaWxzIiwicm91dGVFcnJvciIsIm1lc3NhZ2UiLCJjYWxjdWxhdGVEaXN0YW5jZSIsImxhdDEiLCJsbmcxIiwibGF0MiIsImxuZzIiLCJ0b0ZpeGVkIiwiZGlzdGFuY2VDYWNoZSIsImhhcyIsImdldCIsIlIiLCJkTGF0IiwidG9SYWQiLCJkTG5nIiwiYSIsIk1hdGgiLCJzaW4iLCJjb3MiLCJjIiwiYXRhbjIiLCJzcXJ0IiwiZGlzdGFuY2UiLCJzaXplIiwic2V0IiwiUEkiLCJvcHRpbWl6ZVBhc3Nlbmdlck9yZGVyIiwibGVuZ3RoIiwib3B0aW1pemVkT3JkZXIiLCJuZWFyZXN0TmVpZ2hib3JPcHRpbWl6YXRpb24iLCJ0d29PcHRJbXByb3ZlbWVudCIsInVudmlzaXRlZCIsImN1cnJlbnRMb2NhdGlvbiIsIm5lYXJlc3RJbmRleCIsIm5lYXJlc3REaXN0YW5jZSIsImkiLCJuZWFyZXN0UGFzc2VuZ2VyIiwic3BsaWNlIiwicHVzaCIsIkxhdExuZyIsInJvdXRlIiwiaW1wcm92ZWQiLCJiZXN0Um91dGUiLCJiZXN0RGlzdGFuY2UiLCJjYWxjdWxhdGVUb3RhbFJvdXRlRGlzdGFuY2UiLCJqIiwibmV3Um91dGUiLCJ0d29PcHRTd2FwIiwibmV3RGlzdGFuY2UiLCJ0b3RhbERpc3RhbmNlIiwiY2FsY3VsYXRlUGlja3VwVGltZXMiLCJvcHRpbWl6ZWRQYXNzZW5nZXJzIiwic3RhcnRUaW1lIiwicGlja3VwVGltZXMiLCJjdXJyZW50VGltZSIsImF2ZXJhZ2VTcGVlZCIsInN0b3BUaW1lIiwicGFzc2VuZ2VyIiwidHJhdmVsVGltZU1pbnV0ZXMiLCJnZXRUaW1lIiwiZXN0aW1hdGVkUGlja3VwVGltZSIsImNhbGN1bGF0ZU9wdGltaXplZFJvdXRlIiwiY2FjaGVLZXkiLCJjYWNoZWRSb3V0ZSIsImNvbnNvbGUiLCJsb2ciLCJzdGFydExhdCIsInN0YXJ0TG5nIiwiZGVzdExhdCIsImRlc3RMbmciLCJpc05hTiIsIm5hbWUiLCJKU09OIiwic3RyaW5naWZ5Iiwib3JkZXJlZFBhc3NlbmdlcnMiLCJ3YXlwb2ludHMiLCJsb2NhdGlvbiIsInN0b3BvdmVyIiwicmVxdWVzdCIsIm9yaWdpbiIsInRyYXZlbE1vZGUiLCJUcmF2ZWxNb2RlIiwiRFJJVklORyIsIm9wdGltaXplV2F5cG9pbnRzIiwiZGlyZWN0aW9uc1Jlc3VsdCIsInN0YXR1cyIsIkRpcmVjdGlvbnNTdGF0dXMiLCJPSyIsInJvdXRlcyIsImxlZyIsImxlZ3MiLCJ0b3RhbER1cmF0aW9uIiwiZm9yRWFjaCIsInNlZ21lbnQiLCJkdXJhdGlvbiIsInBvbHlsaW5lUGF0aCIsIm92ZXJ2aWV3X3BhdGgiLCJBcnJheSIsImlzQXJyYXkiLCJwb2ludCIsIndhcm4iLCJvcHRpbWl6ZWRXYXlwb2ludHMiLCJyZXN1bHQiLCJmaW5kQmVzdFJvdXRlIiwiZmFsbGJhY2tFcnJvciIsImNyZWF0ZUZhbGxiYWNrUm91dGUiLCJzdGFydENvb3JkcyIsImRlc3RDb29yZHMiLCJjdXJyZW50Q29vcmRzIiwiY3VycmVudExhdCIsImN1cnJlbnRMbmciLCJmaW5hbExhdCIsImZpbmFsTG5nIiwiaW5kZXgiLCJ0aW1lVG9QYXNzZW5nZXIiLCJmYWxsYmFja1dheXBvaW50cyIsImVzdGltYXRlQm9hcmRpbmdUaW1lIiwicGFzc2VuZ2VyQ291bnQiLCJjYWxjdWxhdGVQaWNrdXBUaW1lc0Zyb21TZWdtZW50cyIsInJvdXRlU2VnbWVudHMiLCJib2FyZGluZ1RpbWUiLCJnZW5lcmF0ZU9wdGltaXphdGlvblN1Z2dlc3Rpb24iLCJyb3VuZCIsInZhbGlkYXRlQWRkcmVzcyIsImFkZHJlc3MiLCJ0cmltIiwiZm9ybWF0UGlja3VwVGltZSIsImVzdGltYXRlZFRpbWUiLCJkaWZmTWludXRlcyIsImhvdXJzIiwiZmxvb3IiLCJtaW51dGVzIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiZGF5IiwibW9udGgiLCJob3VyIiwibWludXRlIiwiTWFwIiwicm91dGVPcHRpbWl6YXRpb25TZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/routeOptimizationService.ts\n"));

/***/ })

});