"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/motorista/page",{

/***/ "(app-pages-browser)/./services/routeOptimizationService.ts":
/*!**********************************************!*\
  !*** ./services/routeOptimizationService.ts ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RouteOptimizationService: () => (/* binding */ RouteOptimizationService),\n/* harmony export */   routeOptimizationService: () => (/* binding */ routeOptimizationService)\n/* harmony export */ });\nclass RouteOptimizationService {\n    clearExpiredCache() {\n        const now = Date.now();\n        for (const [key, value] of this.routeCache.entries()){\n            if (now - value.timestamp > this.CACHE_EXPIRY) {\n                this.routeCache.delete(key);\n            }\n        }\n    }\n    getCacheKey(options) {\n        const { startLocation, passengers, destination, optimizeOrder } = options;\n        const startKey = \"\".concat(startLocation.lat(), \",\").concat(startLocation.lng());\n        const destKey = \"\".concat(destination.lat(), \",\").concat(destination.lng());\n        const passengersKey = passengers.map((p)=>\"\".concat(p.id, \"-\").concat(p.position.lat, \",\").concat(p.position.lng)).sort().join('|');\n        return \"\".concat(startKey, \"-\").concat(destKey, \"-\").concat(passengersKey, \"-\").concat(optimizeOrder);\n    }\n    async initializeService() {\n        var _window_google_maps, _window_google;\n        // Aguarda o carregamento da API do Google Maps\n        await this.waitForGoogleMapsAPI();\n        if ((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_maps = _window_google.maps) === null || _window_google_maps === void 0 ? void 0 : _window_google_maps.DirectionsService) {\n            this.directionsService = new google.maps.DirectionsService();\n        }\n    }\n    waitForGoogleMapsAPI() {\n        return new Promise((resolve, reject)=>{\n            try {\n                var _window_google_maps, _window_google;\n                // Se já estiver carregada\n                if (window.googleMapsApiLoaded === true && ((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_maps = _window_google.maps) === null || _window_google_maps === void 0 ? void 0 : _window_google_maps.DirectionsService)) {\n                    resolve();\n                    return;\n                }\n                // Se houve erro no carregamento\n                if (window.googleMapsApiLoaded === 'error') {\n                    const error = new Error('Google Maps API falhou ao carregar. Verifique se a chave da API está configurada corretamente e se as APIs necessárias estão habilitadas (Maps JavaScript API, Directions API, Geometry API).');\n                    error.code = 'GOOGLE_MAPS_NOT_LOADED';\n                    reject(error);\n                    return;\n                }\n                // Aguarda o carregamento\n                let attempts = 0;\n                const maxAttempts = 50; // 5 segundos máximo\n                const checkInterval = setInterval(()=>{\n                    var _window_google_maps, _window_google;\n                    attempts++;\n                    if (window.googleMapsApiLoaded === true && ((_window_google = window.google) === null || _window_google === void 0 ? void 0 : (_window_google_maps = _window_google.maps) === null || _window_google_maps === void 0 ? void 0 : _window_google_maps.DirectionsService)) {\n                        clearInterval(checkInterval);\n                        resolve();\n                    } else if (window.googleMapsApiLoaded === 'error' || attempts >= maxAttempts) {\n                        clearInterval(checkInterval);\n                        const error = new Error('Timeout ou erro ao carregar Google Maps API. Verifique se a chave da API está configurada corretamente e se as APIs necessárias estão habilitadas (Maps JavaScript API, Directions API, Geometry API).');\n                        error.code = 'GOOGLE_MAPS_NOT_LOADED';\n                        error.details = \"Tentativas: \".concat(attempts, \"/\").concat(maxAttempts);\n                        reject(error);\n                    }\n                }, 100);\n            } catch (error) {\n                const routeError = new Error(\"Erro inesperado ao aguardar Google Maps API: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n                routeError.code = 'UNKNOWN_ERROR';\n                reject(routeError);\n            }\n        });\n    }\n    /**\n     * Calcula a distância entre dois pontos usando a fórmula de Haversine com cache\n     */ calculateDistance(lat1, lng1, lat2, lng2) {\n        // Cria chave para cache (arredonda para 6 casas decimais para evitar cache excessivo)\n        const key = \"\".concat(lat1.toFixed(6), \",\").concat(lng1.toFixed(6), \"-\").concat(lat2.toFixed(6), \",\").concat(lng2.toFixed(6));\n        // Verifica cache\n        if (this.distanceCache.has(key)) {\n            return this.distanceCache.get(key);\n        }\n        const R = 6371; // Raio da Terra em km\n        const dLat = this.toRad(lat2 - lat1);\n        const dLng = this.toRad(lng2 - lng1);\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        const distance = R * c;\n        // Armazena no cache (limita tamanho do cache)\n        if (this.distanceCache.size < 1000) {\n            this.distanceCache.set(key, distance);\n        }\n        return distance;\n    }\n    toRad(value) {\n        return value * Math.PI / 180;\n    }\n    /**\n     * Algoritmo de otimização usando Nearest Neighbor com melhorias e 2-opt\n     */ optimizePassengerOrder(startLocation, passengers, destination) {\n        if (passengers.length <= 1) return passengers;\n        // Primeiro, aplica Nearest Neighbor\n        let optimizedOrder = this.nearestNeighborOptimization(startLocation, passengers, destination);\n        // Em seguida, aplica 2-opt para melhorar a rota\n        if (optimizedOrder.length > 3) {\n            optimizedOrder = this.twoOptImprovement(startLocation, optimizedOrder, destination);\n        }\n        return optimizedOrder;\n    }\n    /**\n     * Algoritmo Nearest Neighbor básico\n     */ nearestNeighborOptimization(startLocation, passengers, destination) {\n        const unvisited = [\n            ...passengers\n        ];\n        const optimizedOrder = [];\n        let currentLocation = startLocation;\n        while(unvisited.length > 0){\n            let nearestIndex = 0;\n            let nearestDistance = this.calculateDistance(currentLocation.lat(), currentLocation.lng(), unvisited[0].position.lat, unvisited[0].position.lng);\n            // Encontra o passageiro mais próximo\n            for(let i = 1; i < unvisited.length; i++){\n                const distance = this.calculateDistance(currentLocation.lat(), currentLocation.lng(), unvisited[i].position.lat, unvisited[i].position.lng);\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    nearestIndex = i;\n                }\n            }\n            // Adiciona o passageiro mais próximo à rota otimizada\n            const nearestPassenger = unvisited.splice(nearestIndex, 1)[0];\n            optimizedOrder.push(nearestPassenger);\n            currentLocation = new google.maps.LatLng(nearestPassenger.position.lat, nearestPassenger.position.lng);\n        }\n        return optimizedOrder;\n    }\n    /**\n     * Algoritmo 2-opt para melhorar a rota existente\n     */ twoOptImprovement(startLocation, route, destination) {\n        let improved = true;\n        let bestRoute = [\n            ...route\n        ];\n        let bestDistance = this.calculateTotalRouteDistance(startLocation, bestRoute, destination);\n        while(improved){\n            improved = false;\n            for(let i = 1; i < route.length - 2; i++){\n                for(let j = i + 1; j < route.length; j++){\n                    if (j - i === 1) continue; // Skip adjacent edges\n                    // Cria nova rota com 2-opt swap\n                    const newRoute = this.twoOptSwap(route, i, j);\n                    const newDistance = this.calculateTotalRouteDistance(startLocation, newRoute, destination);\n                    if (newDistance < bestDistance) {\n                        bestRoute = newRoute;\n                        bestDistance = newDistance;\n                        route = newRoute;\n                        improved = true;\n                    }\n                }\n            }\n        }\n        return bestRoute;\n    }\n    /**\n     * Executa o swap 2-opt\n     */ twoOptSwap(route, i, j) {\n        const newRoute = [\n            ...route\n        ];\n        // Reverte a ordem dos elementos entre i e j\n        while(i < j){\n            [newRoute[i], newRoute[j]] = [\n                newRoute[j],\n                newRoute[i]\n            ];\n            i++;\n            j--;\n        }\n        return newRoute;\n    }\n    /**\n     * Calcula a distância total de uma rota\n     */ calculateTotalRouteDistance(startLocation, route, destination) {\n        let totalDistance = 0;\n        let currentLocation = startLocation;\n        // Distância do início até o primeiro passageiro\n        if (route.length > 0) {\n            totalDistance += this.calculateDistance(currentLocation.lat(), currentLocation.lng(), route[0].position.lat, route[0].position.lng);\n        }\n        // Distância entre passageiros\n        for(let i = 0; i < route.length - 1; i++){\n            totalDistance += this.calculateDistance(route[i].position.lat, route[i].position.lng, route[i + 1].position.lat, route[i + 1].position.lng);\n        }\n        // Distância do último passageiro até o destino\n        if (route.length > 0) {\n            totalDistance += this.calculateDistance(route[route.length - 1].position.lat, route[route.length - 1].position.lng, destination.lat(), destination.lng());\n        }\n        return totalDistance;\n    }\n    /**\n     * Calcula horários estimados de coleta baseados na rota otimizada\n     */ calculatePickupTimes(startLocation, optimizedPassengers) {\n        let startTime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Date();\n        const pickupTimes = [];\n        let currentTime = new Date(startTime);\n        let currentLocation = startLocation;\n        // Velocidade média estimada (km/h) - pode ser configurável\n        const averageSpeed = 30; // 30 km/h em área urbana\n        const stopTime = 2; // 2 minutos por parada\n        for (const passenger of optimizedPassengers){\n            // Calcula distância até o passageiro\n            const distance = this.calculateDistance(currentLocation.lat(), currentLocation.lng(), passenger.position.lat, passenger.position.lng);\n            // Calcula tempo de viagem em minutos\n            const travelTimeMinutes = distance / averageSpeed * 60;\n            // Adiciona tempo de viagem ao tempo atual\n            currentTime = new Date(currentTime.getTime() + travelTimeMinutes * 60000);\n            pickupTimes.push({\n                passenger,\n                estimatedPickupTime: new Date(currentTime)\n            });\n            // Adiciona tempo de parada\n            currentTime = new Date(currentTime.getTime() + stopTime * 60000);\n            // Atualiza localização atual\n            currentLocation = new google.maps.LatLng(passenger.position.lat, passenger.position.lng);\n        }\n        return pickupTimes;\n    }\n    /**\n     * Calcula a rota otimizada usando Google Directions API\n     */ async calculateOptimizedRoute(options) {\n        const { startLocation, passengers, destination, optimizeOrder = true } = options;\n        try {\n            // Verifica cache primeiro\n            const cacheKey = this.getCacheKey(options);\n            if (this.routeCache.has(cacheKey)) {\n                const cachedRoute = this.routeCache.get(cacheKey);\n                console.log('Rota encontrada no cache');\n                return cachedRoute;\n            }\n            // Aguarda a inicialização do serviço se necessário\n            if (!this.directionsService) {\n                await this.initializeService();\n            }\n            if (!this.directionsService) {\n                const error = new Error('Google Maps API não está carregada');\n                error.code = 'GOOGLE_MAPS_NOT_LOADED';\n                throw error;\n            }\n            // Validação dos parâmetros de entrada\n            if (!startLocation || !destination) {\n                const error = new Error('Coordenadas de início ou destino não fornecidas');\n                error.code = 'INVALID_COORDINATES';\n                throw error;\n            }\n            // Validação específica para objetos LatLng\n            try {\n                const startLat = typeof startLocation.lat === 'function' ? startLocation.lat() : startLocation.lat;\n                const startLng = typeof startLocation.lng === 'function' ? startLocation.lng() : startLocation.lng;\n                const destLat = typeof destination.lat === 'function' ? destination.lat() : destination.lat;\n                const destLng = typeof destination.lng === 'function' ? destination.lng() : destination.lng;\n                if (typeof startLat !== 'number' || typeof startLng !== 'number' || typeof destLat !== 'number' || typeof destLng !== 'number' || isNaN(startLat) || isNaN(startLng) || isNaN(destLat) || isNaN(destLng)) {\n                    const error = new Error('Coordenadas de início ou destino são inválidas');\n                    error.code = 'INVALID_COORDINATES';\n                    error.details = \"Start: \".concat(startLat, \", \").concat(startLng, \" | Dest: \").concat(destLat, \", \").concat(destLng);\n                    throw error;\n                }\n            } catch (error) {\n                const routeError = new Error(\"Erro ao validar coordenadas: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n                routeError.code = 'INVALID_COORDINATES';\n                throw routeError;\n            }\n            if (!passengers || passengers.length === 0) {\n                const error = new Error('Lista de passageiros não fornecida ou vazia');\n                error.code = 'NO_PASSENGERS';\n                throw error;\n            }\n        } catch (error) {\n            if (error.code) {\n                throw error;\n            }\n            const routeError = new Error(\"Erro inesperado na valida\\xe7\\xe3o inicial: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n            routeError.code = 'UNKNOWN_ERROR';\n            throw routeError;\n        }\n        // Valida coordenadas de todos os passageiros\n        for (const passenger of passengers){\n            if (!passenger.position || typeof passenger.position.lat !== 'number' || typeof passenger.position.lng !== 'number' || isNaN(passenger.position.lat) || isNaN(passenger.position.lng)) {\n                const error = new Error(\"Coordenadas inv\\xe1lidas para o passageiro \".concat(passenger.name || 'desconhecido'));\n                error.code = 'INVALID_COORDINATES';\n                error.details = \"Passageiro: \".concat(passenger.name, \", Posi\\xe7\\xe3o: \").concat(JSON.stringify(passenger.position));\n                throw error;\n            }\n        }\n        // Otimiza a ordem dos passageiros se solicitado\n        const orderedPassengers = optimizeOrder ? this.optimizePassengerOrder(startLocation, passengers, destination) : passengers;\n        // Prepara os waypoints para a API do Google\n        const waypoints = orderedPassengers.map((passenger)=>{\n            try {\n                // Validação adicional antes de criar LatLng\n                if (!passenger.position || typeof passenger.position.lat !== 'number' || typeof passenger.position.lng !== 'number' || isNaN(passenger.position.lat) || isNaN(passenger.position.lng)) {\n                    throw new Error(\"Coordenadas inv\\xe1lidas para passageiro \".concat(passenger.name));\n                }\n                return {\n                    location: new google.maps.LatLng(passenger.position.lat, passenger.position.lng),\n                    stopover: true\n                };\n            } catch (error) {\n                console.error(\"Erro ao criar waypoint para passageiro \".concat(passenger.name, \":\"), error);\n                throw error;\n            }\n        });\n        return new Promise((resolve, reject)=>{\n            try {\n                const request = {\n                    origin: startLocation,\n                    destination: destination,\n                    waypoints: waypoints,\n                    travelMode: google.maps.TravelMode.DRIVING,\n                    optimizeWaypoints: false // Usamos nossa própria otimização\n                };\n                this.directionsService.route(request, (directionsResult, status)=>{\n                    try {\n                        if (status === google.maps.DirectionsStatus.OK && directionsResult) {\n                            const route = directionsResult.routes[0];\n                            const leg = route.legs;\n                            // Calcula distância e duração total\n                            let totalDistance = 0;\n                            let totalDuration = 0;\n                            leg.forEach((segment)=>{\n                                if (segment.distance) totalDistance += segment.distance.value;\n                                if (segment.duration) totalDuration += segment.duration.value;\n                            });\n                            // Extrai o caminho da polyline com validação\n                            const polylinePath = [];\n                            if (route.overview_path && Array.isArray(route.overview_path)) {\n                                route.overview_path.forEach((point)=>{\n                                    try {\n                                        // Valida se o ponto tem coordenadas válidas\n                                        const lat = typeof point.lat === 'function' ? point.lat() : point.lat;\n                                        const lng = typeof point.lng === 'function' ? point.lng() : point.lng;\n                                        if (typeof lat === 'number' && typeof lng === 'number' && !isNaN(lat) && !isNaN(lng)) {\n                                            polylinePath.push(point);\n                                        }\n                                    } catch (error) {\n                                        console.warn('Erro ao processar ponto do polyline:', error);\n                                    }\n                                });\n                            }\n                            // Cria os waypoints ordenados com validação\n                            const optimizedWaypoints = [\n                                startLocation\n                            ];\n                            orderedPassengers.forEach((passenger)=>{\n                                try {\n                                    if (passenger.position && typeof passenger.position.lat === 'number' && typeof passenger.position.lng === 'number' && !isNaN(passenger.position.lat) && !isNaN(passenger.position.lng)) {\n                                        optimizedWaypoints.push(new google.maps.LatLng(passenger.position.lat, passenger.position.lng));\n                                    }\n                                } catch (error) {\n                                    console.warn(\"Erro ao criar waypoint para passageiro \".concat(passenger.name, \":\"), error);\n                                }\n                            });\n                            optimizedWaypoints.push(destination);\n                            // Calcula horários estimados de pickup\n                            const pickupTimes = this.calculatePickupTimes(startLocation, orderedPassengers, new Date());\n                            const result = {\n                                waypoints: optimizedWaypoints,\n                                orderedPassengers,\n                                totalDistance: totalDistance / 1000,\n                                totalDuration: totalDuration / 60,\n                                polylinePath,\n                                pickupTimes\n                            };\n                            // Armazena no cache\n                            result.timestamp = Date.now();\n                            const cacheKey = this.getCacheKey(options);\n                            this.routeCache.set(cacheKey, result);\n                            resolve(result);\n                        } else {\n                            const error = new Error(\"Falha ao calcular rota: \".concat(status));\n                            error.code = 'DIRECTIONS_API_ERROR';\n                            error.details = \"Status: \".concat(status);\n                            reject(error);\n                        }\n                    } catch (error) {\n                        const routeError = new Error(\"Erro ao processar resultado da rota: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n                        routeError.code = 'UNKNOWN_ERROR';\n                        reject(routeError);\n                    }\n                });\n            } catch (error) {\n                const routeError = new Error(\"Erro ao criar requisi\\xe7\\xe3o de rota: \".concat(error instanceof Error ? error.message : 'Erro desconhecido'));\n                routeError.code = 'UNKNOWN_ERROR';\n                reject(routeError);\n            }\n        });\n    }\n    /**\n     * Encontra a melhor rota possível, com fallback para rota não otimizada\n     */ async findBestRoute(options) {\n        try {\n            // Aguarda a inicialização do serviço se necessário\n            if (!this.directionsService) {\n                await this.initializeService();\n            }\n            // Tenta calcular rota otimizada\n            return await this.calculateOptimizedRoute(options);\n        } catch (error) {\n            console.warn('Erro ao calcular rota otimizada:', error);\n            // Fallback: rota sem otimização\n            try {\n                return await this.calculateOptimizedRoute({\n                    ...options,\n                    optimizeOrder: false\n                });\n            } catch (fallbackError) {\n                console.error('Erro ao calcular rota de fallback:', fallbackError);\n                // Se ainda assim falhar, retorna uma rota básica com dados estimados\n                return this.createFallbackRoute(options);\n            }\n        }\n    }\n    /**\n     * Cria uma rota de fallback com dados estimados quando a API falha\n     */ createFallbackRoute(options) {\n        const { startLocation, passengers, destination } = options;\n        // Validação e conversão de coordenadas para formato simples\n        if (!startLocation || !destination) {\n            throw new Error('Coordenadas de início ou destino não fornecidas');\n        }\n        const startCoords = {\n            lat: typeof startLocation.lat === 'function' ? startLocation.lat() : startLocation.lat,\n            lng: typeof startLocation.lng === 'function' ? startLocation.lng() : startLocation.lng\n        };\n        const destCoords = {\n            lat: typeof destination.lat === 'function' ? destination.lat() : destination.lat,\n            lng: typeof destination.lng === 'function' ? destination.lng() : destination.lng\n        };\n        // Validação das coordenadas convertidas\n        if (typeof startCoords.lat !== 'number' || typeof startCoords.lng !== 'number' || typeof destCoords.lat !== 'number' || typeof destCoords.lng !== 'number') {\n            throw new Error('Coordenadas inválidas fornecidas');\n        }\n        // Validação dos passageiros e suas coordenadas\n        if (!passengers || passengers.length === 0) {\n            throw new Error('Lista de passageiros não fornecida ou vazia');\n        }\n        // Valida coordenadas de todos os passageiros\n        for (const passenger of passengers){\n            if (!passenger.position || typeof passenger.position.lat !== 'number' || typeof passenger.position.lng !== 'number') {\n                throw new Error(\"Coordenadas inv\\xe1lidas para o passageiro \".concat(passenger.name || 'desconhecido'));\n            }\n        }\n        // Calcula distâncias estimadas usando Haversine\n        let totalDistance = 0;\n        let currentCoords = startCoords;\n        for (const passenger of passengers){\n            const currentLat = typeof currentCoords.lat === 'function' ? currentCoords.lat() : currentCoords.lat;\n            const currentLng = typeof currentCoords.lng === 'function' ? currentCoords.lng() : currentCoords.lng;\n            totalDistance += this.calculateDistance(currentLat, currentLng, passenger.position.lat, passenger.position.lng);\n            currentCoords = passenger.position;\n        }\n        // Adiciona distância até o destino\n        const finalLat = typeof currentCoords.lat === 'function' ? currentCoords.lat() : currentCoords.lat;\n        const finalLng = typeof currentCoords.lng === 'function' ? currentCoords.lng() : currentCoords.lng;\n        totalDistance += this.calculateDistance(finalLat, finalLng, destCoords.lat, destCoords.lng);\n        // Estima duração (assumindo velocidade média de 30 km/h no trânsito urbano)\n        const totalDuration = totalDistance / 30 * 60; // em minutos\n        // Calcula horários estimados simplificados para fallback\n        const pickupTimes = [];\n        const startTime = new Date();\n        let currentTime = new Date(startTime);\n        passengers.forEach((passenger, index)=>{\n            // Adiciona tempo estimado baseado na distância\n            const timeToPassenger = (index + 1) * (totalDuration / passengers.length);\n            currentTime = new Date(startTime.getTime() + timeToPassenger * 60 * 1000);\n            pickupTimes.push({\n                passenger,\n                estimatedPickupTime: new Date(currentTime)\n            });\n        });\n        // Cria waypoints básicos para fallback\n        const fallbackWaypoints = [];\n        try {\n            fallbackWaypoints.push(new google.maps.LatLng(startCoords.lat, startCoords.lng));\n            passengers.forEach((passenger)=>{\n                if (passenger.position) {\n                    fallbackWaypoints.push(new google.maps.LatLng(passenger.position.lat, passenger.position.lng));\n                }\n            });\n            fallbackWaypoints.push(new google.maps.LatLng(destCoords.lat, destCoords.lng));\n        } catch (error) {\n            console.warn('Erro ao criar waypoints de fallback:', error);\n        }\n        return {\n            waypoints: fallbackWaypoints,\n            orderedPassengers: passengers,\n            totalDistance,\n            totalDuration,\n            polylinePath: [],\n            pickupTimes\n        };\n    }\n    /**\n     * Estima o tempo de embarque baseado no número de passageiros\n     */ estimateBoardingTime(passengerCount) {\n        // Estima 30 segundos por passageiro + 1 minuto base\n        return 1 + passengerCount * 0.5;\n    }\n    /**\n     * Calcula o horário estimado de chegada para cada passageiro (método alternativo para compatibilidade)\n     */ calculatePickupTimesFromSegments(startTime, orderedPassengers, routeSegments) {\n        const pickupTimes = [];\n        let currentTime = new Date(startTime);\n        orderedPassengers.forEach((passenger, index)=>{\n            if (index < routeSegments.length) {\n                const segment = routeSegments[index];\n                if (segment.duration) {\n                    currentTime = new Date(currentTime.getTime() + segment.duration.value * 1000);\n                }\n            }\n            pickupTimes.push({\n                passenger,\n                estimatedPickupTime: new Date(currentTime)\n            });\n            // Adiciona tempo de embarque\n            const boardingTime = this.estimateBoardingTime(1);\n            currentTime = new Date(currentTime.getTime() + boardingTime * 60 * 1000);\n        });\n        return pickupTimes;\n    }\n    /**\n     * Gera sugestões de otimização para uma rota\n     */ generateOptimizationSuggestion(passengerCount) {\n        if (passengerCount === 0) {\n            return \"Adicione passageiros para ver sugestões de otimização.\";\n        }\n        if (passengerCount === 1) {\n            return \"✅ Rota simples com 1 passageiro - sem necessidade de otimização.\";\n        }\n        if (passengerCount <= 3) {\n            return \"\\uD83D\\uDE8C Rota com \".concat(passengerCount, \" passageiros - otimiza\\xe7\\xe3o autom\\xe1tica aplicada para minimizar dist\\xe2ncia.\");\n        }\n        if (passengerCount <= 6) {\n            return \"\\uD83C\\uDFAF Rota com \".concat(passengerCount, \" passageiros - algoritmo avan\\xe7ado aplicado (Nearest Neighbor + 2-opt) para m\\xe1xima efici\\xeancia.\");\n        }\n        return \"⚡ Rota complexa com \".concat(passengerCount, \" passageiros - otimiza\\xe7\\xe3o inteligente aplicada. Tempo estimado de economia: \").concat(Math.round(passengerCount * 0.8), \" minutos.\");\n    }\n    /**\n     * Valida se um endereço tem coordenadas válidas\n     */ validateAddress(address, position) {\n        if (!address || address.trim().length < 10) {\n            return false;\n        }\n        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number' || isNaN(position.lat) || isNaN(position.lng) || position.lat === 0 && position.lng === 0) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Formata tempo estimado de coleta\n     */ formatPickupTime(estimatedTime) {\n        const now = new Date();\n        const diffMinutes = Math.round((estimatedTime.getTime() - now.getTime()) / (1000 * 60));\n        if (diffMinutes < 0) {\n            return \"Horário passado\";\n        }\n        if (diffMinutes < 60) {\n            return \"\".concat(diffMinutes, \" min\");\n        }\n        const hours = Math.floor(diffMinutes / 60);\n        const minutes = diffMinutes % 60;\n        if (hours < 24) {\n            return \"\".concat(hours, \"h\").concat(minutes > 0 ? \" \".concat(minutes, \"min\") : '');\n        }\n        return estimatedTime.toLocaleDateString('pt-BR', {\n            day: '2-digit',\n            month: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit'\n        });\n    }\n    constructor(){\n        this.directionsService = null;\n        this.distanceCache = new Map();\n        this.routeCache = new Map();\n        this.CACHE_EXPIRY = 5 * 60 * 1000; // 5 minutos\n        this.initializeService();\n        // Limpa cache periodicamente\n        setInterval(()=>this.clearExpiredCache(), 60000); // A cada minuto\n    }\n}\nconst routeOptimizationService = new RouteOptimizationService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3JvdXRlT3B0aW1pemF0aW9uU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQXVCTyxNQUFNQTtJQVlEQyxvQkFBMEI7UUFDOUIsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztRQUNwQixLQUFLLE1BQU0sQ0FBQ0UsS0FBS0MsTUFBTSxJQUFJLElBQUksQ0FBQ0MsVUFBVSxDQUFDQyxPQUFPLEdBQUk7WUFDbEQsSUFBSUwsTUFBTSxNQUFlTSxTQUFTLEdBQUcsSUFBSSxDQUFDQyxZQUFZLEVBQUU7Z0JBQ3BELElBQUksQ0FBQ0gsVUFBVSxDQUFDSSxNQUFNLENBQUNOO1lBQzNCO1FBQ0o7SUFDSjtJQUVRTyxZQUFZQyxPQUFpQyxFQUFVO1FBQzNELE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxVQUFVLEVBQUVDLFdBQVcsRUFBRUMsYUFBYSxFQUFFLEdBQUdKO1FBQ2xFLE1BQU1LLFdBQVcsR0FBMEJKLE9BQXZCQSxjQUFjSyxHQUFHLElBQUcsS0FBdUIsT0FBcEJMLGNBQWNNLEdBQUc7UUFDNUQsTUFBTUMsVUFBVSxHQUF3QkwsT0FBckJBLFlBQVlHLEdBQUcsSUFBRyxLQUFxQixPQUFsQkgsWUFBWUksR0FBRztRQUN2RCxNQUFNRSxnQkFBZ0JQLFdBQ2pCUSxHQUFHLENBQUNDLENBQUFBLElBQUssR0FBV0EsT0FBUkEsRUFBRUMsRUFBRSxFQUFDLEtBQXFCRCxPQUFsQkEsRUFBRUUsUUFBUSxDQUFDUCxHQUFHLEVBQUMsS0FBa0IsT0FBZkssRUFBRUUsUUFBUSxDQUFDTixHQUFHLEdBQ3BETyxJQUFJLEdBQ0pDLElBQUksQ0FBQztRQUNWLE9BQU8sR0FBZVAsT0FBWkgsVUFBUyxLQUFjSSxPQUFYRCxTQUFRLEtBQW9CSixPQUFqQkssZUFBYyxLQUFpQixPQUFkTDtJQUN0RDtJQUVBLE1BQWNZLG9CQUFtQztZQUl6Q0MscUJBQUFBO1FBSEosK0NBQStDO1FBQy9DLE1BQU0sSUFBSSxDQUFDQyxvQkFBb0I7UUFF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cm9cXERvY3VtZW50c1xcZ29sZmZveFxcc2VydmljZXNcXHJvdXRlT3B0aW1pemF0aW9uU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFBhc3NlbmdlciwgQ29tcGFueSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpbWl6ZWRSb3V0ZSB7XG4gICAgd2F5cG9pbnRzOiBnb29nbGUubWFwcy5MYXRMbmdbXTtcbiAgICBvcmRlcmVkUGFzc2VuZ2VyczogUGFzc2VuZ2VyW107XG4gICAgdG90YWxEaXN0YW5jZTogbnVtYmVyO1xuICAgIHRvdGFsRHVyYXRpb246IG51bWJlcjtcbiAgICBwb2x5bGluZVBhdGg6IGdvb2dsZS5tYXBzLkxhdExuZ1tdO1xuICAgIHBpY2t1cFRpbWVzPzogeyBwYXNzZW5nZXI6IFBhc3NlbmdlcjsgZXN0aW1hdGVkUGlja3VwVGltZTogRGF0ZSB9W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVPcHRpbWl6YXRpb25PcHRpb25zIHtcbiAgICBzdGFydExvY2F0aW9uOiBnb29nbGUubWFwcy5MYXRMbmc7XG4gICAgcGFzc2VuZ2VyczogUGFzc2VuZ2VyW107XG4gICAgZGVzdGluYXRpb246IGdvb2dsZS5tYXBzLkxhdExuZztcbiAgICBvcHRpbWl6ZU9yZGVyPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29kZTogJ0dPT0dMRV9NQVBTX05PVF9MT0FERUQnIHwgJ0lOVkFMSURfQ09PUkRJTkFURVMnIHwgJ05PX1BBU1NFTkdFUlMnIHwgJ0RJUkVDVElPTlNfQVBJX0VSUk9SJyB8ICdVTktOT1dOX0VSUk9SJztcbiAgICBkZXRhaWxzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgUm91dGVPcHRpbWl6YXRpb25TZXJ2aWNlIHtcbiAgICBwcml2YXRlIGRpcmVjdGlvbnNTZXJ2aWNlOiBnb29nbGUubWFwcy5EaXJlY3Rpb25zU2VydmljZSB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgZGlzdGFuY2VDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgcHJpdmF0ZSByb3V0ZUNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIE9wdGltaXplZFJvdXRlPigpO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgQ0FDSEVfRVhQSVJZID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dG9zXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplU2VydmljZSgpO1xuICAgICAgICAvLyBMaW1wYSBjYWNoZSBwZXJpb2RpY2FtZW50ZVxuICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmNsZWFyRXhwaXJlZENhY2hlKCksIDYwMDAwKTsgLy8gQSBjYWRhIG1pbnV0b1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xlYXJFeHBpcmVkQ2FjaGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMucm91dGVDYWNoZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChub3cgLSAodmFsdWUgYXMgYW55KS50aW1lc3RhbXAgPiB0aGlzLkNBQ0hFX0VYUElSWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm91dGVDYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q2FjaGVLZXkob3B0aW9uczogUm91dGVPcHRpbWl6YXRpb25PcHRpb25zKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgeyBzdGFydExvY2F0aW9uLCBwYXNzZW5nZXJzLCBkZXN0aW5hdGlvbiwgb3B0aW1pemVPcmRlciB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBgJHtzdGFydExvY2F0aW9uLmxhdCgpfSwke3N0YXJ0TG9jYXRpb24ubG5nKCl9YDtcbiAgICAgICAgY29uc3QgZGVzdEtleSA9IGAke2Rlc3RpbmF0aW9uLmxhdCgpfSwke2Rlc3RpbmF0aW9uLmxuZygpfWA7XG4gICAgICAgIGNvbnN0IHBhc3NlbmdlcnNLZXkgPSBwYXNzZW5nZXJzXG4gICAgICAgICAgICAubWFwKHAgPT4gYCR7cC5pZH0tJHtwLnBvc2l0aW9uLmxhdH0sJHtwLnBvc2l0aW9uLmxuZ31gKVxuICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICAgICAgcmV0dXJuIGAke3N0YXJ0S2V5fS0ke2Rlc3RLZXl9LSR7cGFzc2VuZ2Vyc0tleX0tJHtvcHRpbWl6ZU9yZGVyfWA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplU2VydmljZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gQWd1YXJkYSBvIGNhcnJlZ2FtZW50byBkYSBBUEkgZG8gR29vZ2xlIE1hcHNcbiAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yR29vZ2xlTWFwc0FQSSgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHdpbmRvdy5nb29nbGU/Lm1hcHM/LkRpcmVjdGlvbnNTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnNTZXJ2aWNlID0gbmV3IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNTZXJ2aWNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHdhaXRGb3JHb29nbGVNYXBzQVBJKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBTZSBqw6EgZXN0aXZlciBjYXJyZWdhZGFcbiAgICAgICAgICAgICAgICBpZiAod2luZG93Lmdvb2dsZU1hcHNBcGlMb2FkZWQgPT09IHRydWUgJiYgd2luZG93Lmdvb2dsZT8ubWFwcz8uRGlyZWN0aW9uc1NlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2UgaG91dmUgZXJybyBubyBjYXJyZWdhbWVudG9cbiAgICAgICAgICAgICAgICBpZiAod2luZG93Lmdvb2dsZU1hcHNBcGlMb2FkZWQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3I6IFJvdXRlQ2FsY3VsYXRpb25FcnJvciA9IG5ldyBFcnJvcignR29vZ2xlIE1hcHMgQVBJIGZhbGhvdSBhbyBjYXJyZWdhci4gVmVyaWZpcXVlIHNlIGEgY2hhdmUgZGEgQVBJIGVzdMOhIGNvbmZpZ3VyYWRhIGNvcnJldGFtZW50ZSBlIHNlIGFzIEFQSXMgbmVjZXNzw6FyaWFzIGVzdMOjbyBoYWJpbGl0YWRhcyAoTWFwcyBKYXZhU2NyaXB0IEFQSSwgRGlyZWN0aW9ucyBBUEksIEdlb21ldHJ5IEFQSSkuJykgYXMgUm91dGVDYWxjdWxhdGlvbkVycm9yO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ0dPT0dMRV9NQVBTX05PVF9MT0FERUQnO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWd1YXJkYSBvIGNhcnJlZ2FtZW50b1xuICAgICAgICAgICAgICAgIGxldCBhdHRlbXB0cyA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1MDsgLy8gNSBzZWd1bmRvcyBtw6F4aW1vXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlTWFwc0FwaUxvYWRlZCA9PT0gdHJ1ZSAmJiB3aW5kb3cuZ29vZ2xlPy5tYXBzPy5EaXJlY3Rpb25zU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuZ29vZ2xlTWFwc0FwaUxvYWRlZCA9PT0gJ2Vycm9yJyB8fCBhdHRlbXB0cyA+PSBtYXhBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ1RpbWVvdXQgb3UgZXJybyBhbyBjYXJyZWdhciBHb29nbGUgTWFwcyBBUEkuIFZlcmlmaXF1ZSBzZSBhIGNoYXZlIGRhIEFQSSBlc3TDoSBjb25maWd1cmFkYSBjb3JyZXRhbWVudGUgZSBzZSBhcyBBUElzIG5lY2Vzc8OhcmlhcyBlc3TDo28gaGFiaWxpdGFkYXMgKE1hcHMgSmF2YVNjcmlwdCBBUEksIERpcmVjdGlvbnMgQVBJLCBHZW9tZXRyeSBBUEkpLicpIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSAnR09PR0xFX01BUFNfTk9UX0xPQURFRCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5kZXRhaWxzID0gYFRlbnRhdGl2YXM6ICR7YXR0ZW1wdHN9LyR7bWF4QXR0ZW1wdHN9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZUVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoYEVycm8gaW5lc3BlcmFkbyBhbyBhZ3VhcmRhciBHb29nbGUgTWFwcyBBUEk6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRXJybyBkZXNjb25oZWNpZG8nfWApIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICByb3V0ZUVycm9yLmNvZGUgPSAnVU5LTk9XTl9FUlJPUic7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJvdXRlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhIGEgZGlzdMOibmNpYSBlbnRyZSBkb2lzIHBvbnRvcyB1c2FuZG8gYSBmw7NybXVsYSBkZSBIYXZlcnNpbmUgY29tIGNhY2hlXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVEaXN0YW5jZShsYXQxOiBudW1iZXIsIGxuZzE6IG51bWJlciwgbGF0MjogbnVtYmVyLCBsbmcyOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBDcmlhIGNoYXZlIHBhcmEgY2FjaGUgKGFycmVkb25kYSBwYXJhIDYgY2FzYXMgZGVjaW1haXMgcGFyYSBldml0YXIgY2FjaGUgZXhjZXNzaXZvKVxuICAgICAgICBjb25zdCBrZXkgPSBgJHtsYXQxLnRvRml4ZWQoNil9LCR7bG5nMS50b0ZpeGVkKDYpfS0ke2xhdDIudG9GaXhlZCg2KX0sJHtsbmcyLnRvRml4ZWQoNil9YDtcbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmaWNhIGNhY2hlXG4gICAgICAgIGlmICh0aGlzLmRpc3RhbmNlQ2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlQ2FjaGUuZ2V0KGtleSkhO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgUiA9IDYzNzE7IC8vIFJhaW8gZGEgVGVycmEgZW0ga21cbiAgICAgICAgY29uc3QgZExhdCA9IHRoaXMudG9SYWQobGF0MiAtIGxhdDEpO1xuICAgICAgICBjb25zdCBkTG5nID0gdGhpcy50b1JhZChsbmcyIC0gbG5nMSk7XG4gICAgICAgIGNvbnN0IGEgPSBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xuICAgICAgICAgICAgICAgICAgTWF0aC5jb3ModGhpcy50b1JhZChsYXQxKSkgKiBNYXRoLmNvcyh0aGlzLnRvUmFkKGxhdDIpKSAqXG4gICAgICAgICAgICAgICAgICBNYXRoLnNpbihkTG5nIC8gMikgKiBNYXRoLnNpbihkTG5nIC8gMik7XG4gICAgICAgIGNvbnN0IGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IFIgKiBjO1xuXG4gICAgICAgIC8vIEFybWF6ZW5hIG5vIGNhY2hlIChsaW1pdGEgdGFtYW5obyBkbyBjYWNoZSlcbiAgICAgICAgaWYgKHRoaXMuZGlzdGFuY2VDYWNoZS5zaXplIDwgMTAwMCkge1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZUNhY2hlLnNldChrZXksIGRpc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0YW5jZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvUmFkKHZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdmFsdWUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsZ29yaXRtbyBkZSBvdGltaXphw6fDo28gdXNhbmRvIE5lYXJlc3QgTmVpZ2hib3IgY29tIG1lbGhvcmlhcyBlIDItb3B0XG4gICAgICovXG4gICAgcHJpdmF0ZSBvcHRpbWl6ZVBhc3Nlbmdlck9yZGVyKFxuICAgICAgICBzdGFydExvY2F0aW9uOiBnb29nbGUubWFwcy5MYXRMbmcsXG4gICAgICAgIHBhc3NlbmdlcnM6IFBhc3NlbmdlcltdLFxuICAgICAgICBkZXN0aW5hdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nXG4gICAgKTogUGFzc2VuZ2VyW10ge1xuICAgICAgICBpZiAocGFzc2VuZ2Vycy5sZW5ndGggPD0gMSkgcmV0dXJuIHBhc3NlbmdlcnM7XG5cbiAgICAgICAgLy8gUHJpbWVpcm8sIGFwbGljYSBOZWFyZXN0IE5laWdoYm9yXG4gICAgICAgIGxldCBvcHRpbWl6ZWRPcmRlciA9IHRoaXMubmVhcmVzdE5laWdoYm9yT3B0aW1pemF0aW9uKHN0YXJ0TG9jYXRpb24sIHBhc3NlbmdlcnMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVtIHNlZ3VpZGEsIGFwbGljYSAyLW9wdCBwYXJhIG1lbGhvcmFyIGEgcm90YVxuICAgICAgICBpZiAob3B0aW1pemVkT3JkZXIubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgb3B0aW1pemVkT3JkZXIgPSB0aGlzLnR3b09wdEltcHJvdmVtZW50KHN0YXJ0TG9jYXRpb24sIG9wdGltaXplZE9yZGVyLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW1pemVkT3JkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxnb3JpdG1vIE5lYXJlc3QgTmVpZ2hib3IgYsOhc2ljb1xuICAgICAqL1xuICAgIHByaXZhdGUgbmVhcmVzdE5laWdoYm9yT3B0aW1pemF0aW9uKFxuICAgICAgICBzdGFydExvY2F0aW9uOiBnb29nbGUubWFwcy5MYXRMbmcsXG4gICAgICAgIHBhc3NlbmdlcnM6IFBhc3NlbmdlcltdLFxuICAgICAgICBkZXN0aW5hdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nXG4gICAgKTogUGFzc2VuZ2VyW10ge1xuICAgICAgICBjb25zdCB1bnZpc2l0ZWQgPSBbLi4ucGFzc2VuZ2Vyc107XG4gICAgICAgIGNvbnN0IG9wdGltaXplZE9yZGVyOiBQYXNzZW5nZXJbXSA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudExvY2F0aW9uID0gc3RhcnRMb2NhdGlvbjtcblxuICAgICAgICB3aGlsZSAodW52aXNpdGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IG5lYXJlc3REaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLmxhdCgpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbi5sbmcoKSxcbiAgICAgICAgICAgICAgICB1bnZpc2l0ZWRbMF0ucG9zaXRpb24ubGF0LFxuICAgICAgICAgICAgICAgIHVudmlzaXRlZFswXS5wb3NpdGlvbi5sbmdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEVuY29udHJhIG8gcGFzc2FnZWlybyBtYWlzIHByw7N4aW1vXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHVudmlzaXRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLmxhdCgpLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TG9jYXRpb24ubG5nKCksXG4gICAgICAgICAgICAgICAgICAgIHVudmlzaXRlZFtpXS5wb3NpdGlvbi5sYXQsXG4gICAgICAgICAgICAgICAgICAgIHVudmlzaXRlZFtpXS5wb3NpdGlvbi5sbmdcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbmVhcmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRpY2lvbmEgbyBwYXNzYWdlaXJvIG1haXMgcHLDs3hpbW8gw6Agcm90YSBvdGltaXphZGFcbiAgICAgICAgICAgIGNvbnN0IG5lYXJlc3RQYXNzZW5nZXIgPSB1bnZpc2l0ZWQuc3BsaWNlKG5lYXJlc3RJbmRleCwgMSlbMF07XG4gICAgICAgICAgICBvcHRpbWl6ZWRPcmRlci5wdXNoKG5lYXJlc3RQYXNzZW5nZXIpO1xuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhcbiAgICAgICAgICAgICAgICBuZWFyZXN0UGFzc2VuZ2VyLnBvc2l0aW9uLmxhdCxcbiAgICAgICAgICAgICAgICBuZWFyZXN0UGFzc2VuZ2VyLnBvc2l0aW9uLmxuZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpbWl6ZWRPcmRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGdvcml0bW8gMi1vcHQgcGFyYSBtZWxob3JhciBhIHJvdGEgZXhpc3RlbnRlXG4gICAgICovXG4gICAgcHJpdmF0ZSB0d29PcHRJbXByb3ZlbWVudChcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nLFxuICAgICAgICByb3V0ZTogUGFzc2VuZ2VyW10sXG4gICAgICAgIGRlc3RpbmF0aW9uOiBnb29nbGUubWFwcy5MYXRMbmdcbiAgICApOiBQYXNzZW5nZXJbXSB7XG4gICAgICAgIGxldCBpbXByb3ZlZCA9IHRydWU7XG4gICAgICAgIGxldCBiZXN0Um91dGUgPSBbLi4ucm91dGVdO1xuICAgICAgICBsZXQgYmVzdERpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVUb3RhbFJvdXRlRGlzdGFuY2Uoc3RhcnRMb2NhdGlvbiwgYmVzdFJvdXRlLCBkZXN0aW5hdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKGltcHJvdmVkKSB7XG4gICAgICAgICAgICBpbXByb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJvdXRlLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHJvdXRlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqIC0gaSA9PT0gMSkgY29udGludWU7IC8vIFNraXAgYWRqYWNlbnQgZWRnZXNcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIENyaWEgbm92YSByb3RhIGNvbSAyLW9wdCBzd2FwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdXRlID0gdGhpcy50d29PcHRTd2FwKHJvdXRlLCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsUm91dGVEaXN0YW5jZShzdGFydExvY2F0aW9uLCBuZXdSb3V0ZSwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIDwgYmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Um91dGUgPSBuZXdSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgPSBuZXdSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHJvdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiZXN0Um91dGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0YSBvIHN3YXAgMi1vcHRcbiAgICAgKi9cbiAgICBwcml2YXRlIHR3b09wdFN3YXAocm91dGU6IFBhc3NlbmdlcltdLCBpOiBudW1iZXIsIGo6IG51bWJlcik6IFBhc3NlbmdlcltdIHtcbiAgICAgICAgY29uc3QgbmV3Um91dGUgPSBbLi4ucm91dGVdO1xuICAgICAgICBcbiAgICAgICAgLy8gUmV2ZXJ0ZSBhIG9yZGVtIGRvcyBlbGVtZW50b3MgZW50cmUgaSBlIGpcbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBbbmV3Um91dGVbaV0sIG5ld1JvdXRlW2pdXSA9IFtuZXdSb3V0ZVtqXSwgbmV3Um91dGVbaV1dO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3Um91dGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYSBhIGRpc3TDom5jaWEgdG90YWwgZGUgdW1hIHJvdGFcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGN1bGF0ZVRvdGFsUm91dGVEaXN0YW5jZShcbiAgICAgICAgc3RhcnRMb2NhdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nLFxuICAgICAgICByb3V0ZTogUGFzc2VuZ2VyW10sXG4gICAgICAgIGRlc3RpbmF0aW9uOiBnb29nbGUubWFwcy5MYXRMbmdcbiAgICApOiBudW1iZXIge1xuICAgICAgICBsZXQgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGFydExvY2F0aW9uO1xuXG4gICAgICAgIC8vIERpc3TDom5jaWEgZG8gaW7DrWNpbyBhdMOpIG8gcHJpbWVpcm8gcGFzc2FnZWlyb1xuICAgICAgICBpZiAocm91dGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbi5sYXQoKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50TG9jYXRpb24ubG5nKCksXG4gICAgICAgICAgICAgICAgcm91dGVbMF0ucG9zaXRpb24ubGF0LFxuICAgICAgICAgICAgICAgIHJvdXRlWzBdLnBvc2l0aW9uLmxuZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3TDom5jaWEgZW50cmUgcGFzc2FnZWlyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShcbiAgICAgICAgICAgICAgICByb3V0ZVtpXS5wb3NpdGlvbi5sYXQsXG4gICAgICAgICAgICAgICAgcm91dGVbaV0ucG9zaXRpb24ubG5nLFxuICAgICAgICAgICAgICAgIHJvdXRlW2kgKyAxXS5wb3NpdGlvbi5sYXQsXG4gICAgICAgICAgICAgICAgcm91dGVbaSArIDFdLnBvc2l0aW9uLmxuZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3TDom5jaWEgZG8gw7psdGltbyBwYXNzYWdlaXJvIGF0w6kgbyBkZXN0aW5vXG4gICAgICAgIGlmIChyb3V0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgcm91dGVbcm91dGUubGVuZ3RoIC0gMV0ucG9zaXRpb24ubGF0LFxuICAgICAgICAgICAgICAgIHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdLnBvc2l0aW9uLmxuZyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5sYXQoKSxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5sbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b3RhbERpc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGEgaG9yw6FyaW9zIGVzdGltYWRvcyBkZSBjb2xldGEgYmFzZWFkb3MgbmEgcm90YSBvdGltaXphZGFcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGN1bGF0ZVBpY2t1cFRpbWVzKFxuICAgICAgICBzdGFydExvY2F0aW9uOiBnb29nbGUubWFwcy5MYXRMbmcsXG4gICAgICAgIG9wdGltaXplZFBhc3NlbmdlcnM6IFBhc3NlbmdlcltdLFxuICAgICAgICBzdGFydFRpbWU6IERhdGUgPSBuZXcgRGF0ZSgpXG4gICAgKTogeyBwYXNzZW5nZXI6IFBhc3NlbmdlcjsgZXN0aW1hdGVkUGlja3VwVGltZTogRGF0ZSB9W10ge1xuICAgICAgICBjb25zdCBwaWNrdXBUaW1lczogeyBwYXNzZW5nZXI6IFBhc3NlbmdlcjsgZXN0aW1hdGVkUGlja3VwVGltZTogRGF0ZSB9W10gPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoc3RhcnRUaW1lKTtcbiAgICAgICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IHN0YXJ0TG9jYXRpb247XG5cbiAgICAgICAgLy8gVmVsb2NpZGFkZSBtw6lkaWEgZXN0aW1hZGEgKGttL2gpIC0gcG9kZSBzZXIgY29uZmlndXLDoXZlbFxuICAgICAgICBjb25zdCBhdmVyYWdlU3BlZWQgPSAzMDsgLy8gMzAga20vaCBlbSDDoXJlYSB1cmJhbmFcbiAgICAgICAgY29uc3Qgc3RvcFRpbWUgPSAyOyAvLyAyIG1pbnV0b3MgcG9yIHBhcmFkYVxuXG4gICAgICAgIGZvciAoY29uc3QgcGFzc2VuZ2VyIG9mIG9wdGltaXplZFBhc3NlbmdlcnMpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGEgZGlzdMOibmNpYSBhdMOpIG8gcGFzc2FnZWlyb1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbi5sYXQoKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50TG9jYXRpb24ubG5nKCksXG4gICAgICAgICAgICAgICAgcGFzc2VuZ2VyLnBvc2l0aW9uLmxhdCxcbiAgICAgICAgICAgICAgICBwYXNzZW5nZXIucG9zaXRpb24ubG5nXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhIHRlbXBvIGRlIHZpYWdlbSBlbSBtaW51dG9zXG4gICAgICAgICAgICBjb25zdCB0cmF2ZWxUaW1lTWludXRlcyA9IChkaXN0YW5jZSAvIGF2ZXJhZ2VTcGVlZCkgKiA2MDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRpY2lvbmEgdGVtcG8gZGUgdmlhZ2VtIGFvIHRlbXBvIGF0dWFsXG4gICAgICAgICAgICBjdXJyZW50VGltZSA9IG5ldyBEYXRlKGN1cnJlbnRUaW1lLmdldFRpbWUoKSArIHRyYXZlbFRpbWVNaW51dGVzICogNjAwMDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwaWNrdXBUaW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXNzZW5nZXIsXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkUGlja3VwVGltZTogbmV3IERhdGUoY3VycmVudFRpbWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQWRpY2lvbmEgdGVtcG8gZGUgcGFyYWRhXG4gICAgICAgICAgICBjdXJyZW50VGltZSA9IG5ldyBEYXRlKGN1cnJlbnRUaW1lLmdldFRpbWUoKSArIHN0b3BUaW1lICogNjAwMDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBdHVhbGl6YSBsb2NhbGl6YcOnw6NvIGF0dWFsXG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb24gPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKFxuICAgICAgICAgICAgICAgIHBhc3Nlbmdlci5wb3NpdGlvbi5sYXQsXG4gICAgICAgICAgICAgICAgcGFzc2VuZ2VyLnBvc2l0aW9uLmxuZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwaWNrdXBUaW1lcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhIGEgcm90YSBvdGltaXphZGEgdXNhbmRvIEdvb2dsZSBEaXJlY3Rpb25zIEFQSVxuICAgICAqL1xuICAgIGFzeW5jIGNhbGN1bGF0ZU9wdGltaXplZFJvdXRlKG9wdGlvbnM6IFJvdXRlT3B0aW1pemF0aW9uT3B0aW9ucyk6IFByb21pc2U8T3B0aW1pemVkUm91dGU+IHtcbiAgICAgICAgY29uc3QgeyBzdGFydExvY2F0aW9uLCBwYXNzZW5nZXJzLCBkZXN0aW5hdGlvbiwgb3B0aW1pemVPcmRlciA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVmVyaWZpY2EgY2FjaGUgcHJpbWVpcm9cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZXRDYWNoZUtleShvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdXRlQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZFJvdXRlID0gdGhpcy5yb3V0ZUNhY2hlLmdldChjYWNoZUtleSkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSb3RhIGVuY29udHJhZGEgbm8gY2FjaGUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUm91dGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFndWFyZGEgYSBpbmljaWFsaXphw6fDo28gZG8gc2VydmnDp28gc2UgbmVjZXNzw6FyaW9cbiAgICAgICAgICAgIGlmICghdGhpcy5kaXJlY3Rpb25zU2VydmljZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVNlcnZpY2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmRpcmVjdGlvbnNTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3I6IFJvdXRlQ2FsY3VsYXRpb25FcnJvciA9IG5ldyBFcnJvcignR29vZ2xlIE1hcHMgQVBJIG7Do28gZXN0w6EgY2FycmVnYWRhJykgYXMgUm91dGVDYWxjdWxhdGlvbkVycm9yO1xuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSAnR09PR0xFX01BUFNfTk9UX0xPQURFRCc7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYcOnw6NvIGRvcyBwYXLDom1ldHJvcyBkZSBlbnRyYWRhXG4gICAgICAgICAgICBpZiAoIXN0YXJ0TG9jYXRpb24gfHwgIWRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3I6IFJvdXRlQ2FsY3VsYXRpb25FcnJvciA9IG5ldyBFcnJvcignQ29vcmRlbmFkYXMgZGUgaW7DrWNpbyBvdSBkZXN0aW5vIG7Do28gZm9ybmVjaWRhcycpIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ0lOVkFMSURfQ09PUkRJTkFURVMnO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWYWxpZGHDp8OjbyBlc3BlY8OtZmljYSBwYXJhIG9iamV0b3MgTGF0TG5nXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0TGF0ID0gdHlwZW9mIHN0YXJ0TG9jYXRpb24ubGF0ID09PSAnZnVuY3Rpb24nID8gc3RhcnRMb2NhdGlvbi5sYXQoKSA6IChzdGFydExvY2F0aW9uIGFzIGFueSkubGF0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0TG5nID0gdHlwZW9mIHN0YXJ0TG9jYXRpb24ubG5nID09PSAnZnVuY3Rpb24nID8gc3RhcnRMb2NhdGlvbi5sbmcoKSA6IChzdGFydExvY2F0aW9uIGFzIGFueSkubG5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RMYXQgPSB0eXBlb2YgZGVzdGluYXRpb24ubGF0ID09PSAnZnVuY3Rpb24nID8gZGVzdGluYXRpb24ubGF0KCkgOiAoZGVzdGluYXRpb24gYXMgYW55KS5sYXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzdExuZyA9IHR5cGVvZiBkZXN0aW5hdGlvbi5sbmcgPT09ICdmdW5jdGlvbicgPyBkZXN0aW5hdGlvbi5sbmcoKSA6IChkZXN0aW5hdGlvbiBhcyBhbnkpLmxuZztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0TGF0ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc3RhcnRMbmcgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkZXN0TGF0ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGVzdExuZyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNOYU4oc3RhcnRMYXQpIHx8IGlzTmFOKHN0YXJ0TG5nKSB8fCBpc05hTihkZXN0TGF0KSB8fCBpc05hTihkZXN0TG5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcjogUm91dGVDYWxjdWxhdGlvbkVycm9yID0gbmV3IEVycm9yKCdDb29yZGVuYWRhcyBkZSBpbsOtY2lvIG91IGRlc3Rpbm8gc8OjbyBpbnbDoWxpZGFzJykgYXMgUm91dGVDYWxjdWxhdGlvbkVycm9yO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ0lOVkFMSURfQ09PUkRJTkFURVMnO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5kZXRhaWxzID0gYFN0YXJ0OiAke3N0YXJ0TGF0fSwgJHtzdGFydExuZ30gfCBEZXN0OiAke2Rlc3RMYXR9LCAke2Rlc3RMbmd9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZUVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoYEVycm8gYW8gdmFsaWRhciBjb29yZGVuYWRhczogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdFcnJvIGRlc2NvbmhlY2lkbyd9YCkgYXMgUm91dGVDYWxjdWxhdGlvbkVycm9yO1xuICAgICAgICAgICAgICAgIHJvdXRlRXJyb3IuY29kZSA9ICdJTlZBTElEX0NPT1JESU5BVEVTJztcbiAgICAgICAgICAgICAgICB0aHJvdyByb3V0ZUVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXBhc3NlbmdlcnMgfHwgcGFzc2VuZ2Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcjogUm91dGVDYWxjdWxhdGlvbkVycm9yID0gbmV3IEVycm9yKCdMaXN0YSBkZSBwYXNzYWdlaXJvcyBuw6NvIGZvcm5lY2lkYSBvdSB2YXppYScpIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ05PX1BBU1NFTkdFUlMnO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKChlcnJvciBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IpLmNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlRXJyb3I6IFJvdXRlQ2FsY3VsYXRpb25FcnJvciA9IG5ldyBFcnJvcihgRXJybyBpbmVzcGVyYWRvIG5hIHZhbGlkYcOnw6NvIGluaWNpYWw6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRXJybyBkZXNjb25oZWNpZG8nfWApIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgIHJvdXRlRXJyb3IuY29kZSA9ICdVTktOT1dOX0VSUk9SJztcbiAgICAgICAgICAgIHRocm93IHJvdXRlRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGEgY29vcmRlbmFkYXMgZGUgdG9kb3Mgb3MgcGFzc2FnZWlyb3NcbiAgICAgICAgZm9yIChjb25zdCBwYXNzZW5nZXIgb2YgcGFzc2VuZ2Vycykge1xuICAgICAgICAgICAgaWYgKCFwYXNzZW5nZXIucG9zaXRpb24gfHwgXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBhc3Nlbmdlci5wb3NpdGlvbi5sYXQgIT09ICdudW1iZXInIHx8IFxuICAgICAgICAgICAgICAgIHR5cGVvZiBwYXNzZW5nZXIucG9zaXRpb24ubG5nICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICAgIGlzTmFOKHBhc3Nlbmdlci5wb3NpdGlvbi5sYXQpIHx8IFxuICAgICAgICAgICAgICAgIGlzTmFOKHBhc3Nlbmdlci5wb3NpdGlvbi5sbmcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3I6IFJvdXRlQ2FsY3VsYXRpb25FcnJvciA9IG5ldyBFcnJvcihgQ29vcmRlbmFkYXMgaW52w6FsaWRhcyBwYXJhIG8gcGFzc2FnZWlybyAke3Bhc3Nlbmdlci5uYW1lIHx8ICdkZXNjb25oZWNpZG8nfWApIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ0lOVkFMSURfQ09PUkRJTkFURVMnO1xuICAgICAgICAgICAgICAgIGVycm9yLmRldGFpbHMgPSBgUGFzc2FnZWlybzogJHtwYXNzZW5nZXIubmFtZX0sIFBvc2nDp8OjbzogJHtKU09OLnN0cmluZ2lmeShwYXNzZW5nZXIucG9zaXRpb24pfWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGltaXphIGEgb3JkZW0gZG9zIHBhc3NhZ2Vpcm9zIHNlIHNvbGljaXRhZG9cbiAgICAgICAgY29uc3Qgb3JkZXJlZFBhc3NlbmdlcnMgPSBvcHRpbWl6ZU9yZGVyIFxuICAgICAgICAgICAgPyB0aGlzLm9wdGltaXplUGFzc2VuZ2VyT3JkZXIoc3RhcnRMb2NhdGlvbiwgcGFzc2VuZ2VycywgZGVzdGluYXRpb24pXG4gICAgICAgICAgICA6IHBhc3NlbmdlcnM7XG5cbiAgICAgICAgLy8gUHJlcGFyYSBvcyB3YXlwb2ludHMgcGFyYSBhIEFQSSBkbyBHb29nbGVcbiAgICAgICAgY29uc3Qgd2F5cG9pbnRzID0gb3JkZXJlZFBhc3NlbmdlcnMubWFwKHBhc3NlbmdlciA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFZhbGlkYcOnw6NvIGFkaWNpb25hbCBhbnRlcyBkZSBjcmlhciBMYXRMbmdcbiAgICAgICAgICAgICAgICBpZiAoIXBhc3Nlbmdlci5wb3NpdGlvbiB8fCBcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBhc3Nlbmdlci5wb3NpdGlvbi5sYXQgIT09ICdudW1iZXInIHx8IFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGFzc2VuZ2VyLnBvc2l0aW9uLmxuZyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNOYU4ocGFzc2VuZ2VyLnBvc2l0aW9uLmxhdCkgfHwgXG4gICAgICAgICAgICAgICAgICAgIGlzTmFOKHBhc3Nlbmdlci5wb3NpdGlvbi5sbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29vcmRlbmFkYXMgaW52w6FsaWRhcyBwYXJhIHBhc3NhZ2Vpcm8gJHtwYXNzZW5nZXIubmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IG5ldyBnb29nbGUubWFwcy5MYXRMbmcocGFzc2VuZ2VyLnBvc2l0aW9uLmxhdCwgcGFzc2VuZ2VyLnBvc2l0aW9uLmxuZyksXG4gICAgICAgICAgICAgICAgICAgIHN0b3BvdmVyOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJybyBhbyBjcmlhciB3YXlwb2ludCBwYXJhIHBhc3NhZ2Vpcm8gJHtwYXNzZW5nZXIubmFtZX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8T3B0aW1pemVkUm91dGU+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdDogZ29vZ2xlLm1hcHMuRGlyZWN0aW9uc1JlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogc3RhcnRMb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICB3YXlwb2ludHM6IHdheXBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVsTW9kZTogZ29vZ2xlLm1hcHMuVHJhdmVsTW9kZS5EUklWSU5HLFxuICAgICAgICAgICAgICAgICAgICBvcHRpbWl6ZVdheXBvaW50czogZmFsc2UgLy8gVXNhbW9zIG5vc3NhIHByw7NwcmlhIG90aW1pemHDp8Ojb1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnNTZXJ2aWNlIS5yb3V0ZShyZXF1ZXN0LCAoZGlyZWN0aW9uc1Jlc3VsdCwgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBnb29nbGUubWFwcy5EaXJlY3Rpb25zU3RhdHVzLk9LICYmIGRpcmVjdGlvbnNSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm91dGUgPSBkaXJlY3Rpb25zUmVzdWx0LnJvdXRlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVnID0gcm91dGUubGVncztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGEgZGlzdMOibmNpYSBlIGR1cmHDp8OjbyB0b3RhbFxuICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbER1cmF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxlZy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQuZGlzdGFuY2UpIHRvdGFsRGlzdGFuY2UgKz0gc2VnbWVudC5kaXN0YW5jZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LmR1cmF0aW9uKSB0b3RhbER1cmF0aW9uICs9IHNlZ21lbnQuZHVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhaSBvIGNhbWluaG8gZGEgcG9seWxpbmUgY29tIHZhbGlkYcOnw6NvXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlsaW5lUGF0aDogZ29vZ2xlLm1hcHMuTGF0TG5nW10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlLm92ZXJ2aWV3X3BhdGggJiYgQXJyYXkuaXNBcnJheShyb3V0ZS5vdmVydmlld19wYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUub3ZlcnZpZXdfcGF0aC5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGEgc2UgbyBwb250byB0ZW0gY29vcmRlbmFkYXMgdsOhbGlkYXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ID0gdHlwZW9mIHBvaW50LmxhdCA9PT0gJ2Z1bmN0aW9uJyA/IHBvaW50LmxhdCgpIDogcG9pbnQubGF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsbmcgPSB0eXBlb2YgcG9pbnQubG5nID09PSAnZnVuY3Rpb24nID8gcG9pbnQubG5nKCkgOiBwb2ludC5sbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhdCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxuZyA9PT0gJ251bWJlcicgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNOYU4obGF0KSAmJiAhaXNOYU4obG5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWxpbmVQYXRoLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvIGFvIHByb2Nlc3NhciBwb250byBkbyBwb2x5bGluZTonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDcmlhIG9zIHdheXBvaW50cyBvcmRlbmFkb3MgY29tIHZhbGlkYcOnw6NvXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGltaXplZFdheXBvaW50czogZ29vZ2xlLm1hcHMuTGF0TG5nW10gPSBbc3RhcnRMb2NhdGlvbiBhcyBnb29nbGUubWFwcy5MYXRMbmddO1xuICAgICAgICAgICAgICAgICAgICBvcmRlcmVkUGFzc2VuZ2Vycy5mb3JFYWNoKHBhc3NlbmdlciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXNzZW5nZXIucG9zaXRpb24gJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwYXNzZW5nZXIucG9zaXRpb24ubGF0ID09PSAnbnVtYmVyJyAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBhc3Nlbmdlci5wb3NpdGlvbi5sbmcgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc05hTihwYXNzZW5nZXIucG9zaXRpb24ubGF0KSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzTmFOKHBhc3Nlbmdlci5wb3NpdGlvbi5sbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXplZFdheXBvaW50cy5wdXNoKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzZW5nZXIucG9zaXRpb24ubGF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VuZ2VyLnBvc2l0aW9uLmxuZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXJybyBhbyBjcmlhciB3YXlwb2ludCBwYXJhIHBhc3NhZ2Vpcm8gJHtwYXNzZW5nZXIubmFtZX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pemVkV2F5cG9pbnRzLnB1c2goZGVzdGluYXRpb24gYXMgZ29vZ2xlLm1hcHMuTGF0TG5nKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhIGhvcsOhcmlvcyBlc3RpbWFkb3MgZGUgcGlja3VwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpY2t1cFRpbWVzID0gdGhpcy5jYWxjdWxhdGVQaWNrdXBUaW1lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkUGFzc2VuZ2VycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogT3B0aW1pemVkUm91dGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdheXBvaW50czogb3B0aW1pemVkV2F5cG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkUGFzc2VuZ2VycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxEaXN0YW5jZTogdG90YWxEaXN0YW5jZSAvIDEwMDAsIC8vIENvbnZlcnRlIHBhcmEga21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxEdXJhdGlvbjogdG90YWxEdXJhdGlvbiAvIDYwLCAvLyBDb252ZXJ0ZSBwYXJhIG1pbnV0b3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWxpbmVQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrdXBUaW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcm1hemVuYSBubyBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQgYXMgYW55KS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZXRDYWNoZUtleShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdXRlQ2FjaGUuc2V0KGNhY2hlS2V5LCByZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcjogUm91dGVDYWxjdWxhdGlvbkVycm9yID0gbmV3IEVycm9yKGBGYWxoYSBhbyBjYWxjdWxhciByb3RhOiAke3N0YXR1c31gKSBhcyBSb3V0ZUNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdESVJFQ1RJT05TX0FQSV9FUlJPUic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGV0YWlscyA9IGBTdGF0dXM6ICR7c3RhdHVzfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlRXJyb3I6IFJvdXRlQ2FsY3VsYXRpb25FcnJvciA9IG5ldyBFcnJvcihgRXJybyBhbyBwcm9jZXNzYXIgcmVzdWx0YWRvIGRhIHJvdGE6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRXJybyBkZXNjb25oZWNpZG8nfWApIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlRXJyb3IuY29kZSA9ICdVTktOT1dOX0VSUk9SJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyb3V0ZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZUVycm9yOiBSb3V0ZUNhbGN1bGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoYEVycm8gYW8gY3JpYXIgcmVxdWlzacOnw6NvIGRlIHJvdGE6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRXJybyBkZXNjb25oZWNpZG8nfWApIGFzIFJvdXRlQ2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgICAgICAgICByb3V0ZUVycm9yLmNvZGUgPSAnVU5LTk9XTl9FUlJPUic7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJvdXRlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvbnRyYSBhIG1lbGhvciByb3RhIHBvc3PDrXZlbCwgY29tIGZhbGxiYWNrIHBhcmEgcm90YSBuw6NvIG90aW1pemFkYVxuICAgICAqL1xuICAgIGFzeW5jIGZpbmRCZXN0Um91dGUob3B0aW9uczogUm91dGVPcHRpbWl6YXRpb25PcHRpb25zKTogUHJvbWlzZTxPcHRpbWl6ZWRSb3V0ZT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQWd1YXJkYSBhIGluaWNpYWxpemHDp8OjbyBkbyBzZXJ2acOnbyBzZSBuZWNlc3PDoXJpb1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpcmVjdGlvbnNTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplU2VydmljZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUZW50YSBjYWxjdWxhciByb3RhIG90aW1pemFkYVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FsY3VsYXRlT3B0aW1pemVkUm91dGUob3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm8gYW8gY2FsY3VsYXIgcm90YSBvdGltaXphZGE6JywgZXJyb3IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGYWxsYmFjazogcm90YSBzZW0gb3RpbWl6YcOnw6NvXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNhbGN1bGF0ZU9wdGltaXplZFJvdXRlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pemVPcmRlcjogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNhbGN1bGFyIHJvdGEgZGUgZmFsbGJhY2s6JywgZmFsbGJhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU2UgYWluZGEgYXNzaW0gZmFsaGFyLCByZXRvcm5hIHVtYSByb3RhIGLDoXNpY2EgY29tIGRhZG9zIGVzdGltYWRvc1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZhbGxiYWNrUm91dGUob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmlhIHVtYSByb3RhIGRlIGZhbGxiYWNrIGNvbSBkYWRvcyBlc3RpbWFkb3MgcXVhbmRvIGEgQVBJIGZhbGhhXG4gICAgICovXG4gICAgcHJpdmF0ZSBjcmVhdGVGYWxsYmFja1JvdXRlKG9wdGlvbnM6IFJvdXRlT3B0aW1pemF0aW9uT3B0aW9ucyk6IE9wdGltaXplZFJvdXRlIHtcbiAgICAgICAgY29uc3QgeyBzdGFydExvY2F0aW9uLCBwYXNzZW5nZXJzLCBkZXN0aW5hdGlvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYcOnw6NvIGUgY29udmVyc8OjbyBkZSBjb29yZGVuYWRhcyBwYXJhIGZvcm1hdG8gc2ltcGxlc1xuICAgICAgICBpZiAoIXN0YXJ0TG9jYXRpb24gfHwgIWRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvb3JkZW5hZGFzIGRlIGluw61jaW8gb3UgZGVzdGlubyBuw6NvIGZvcm5lY2lkYXMnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3Qgc3RhcnRDb29yZHMgPSB7XG4gICAgICAgICAgICBsYXQ6IHR5cGVvZiBzdGFydExvY2F0aW9uLmxhdCA9PT0gJ2Z1bmN0aW9uJyA/IHN0YXJ0TG9jYXRpb24ubGF0KCkgOiBzdGFydExvY2F0aW9uLmxhdCxcbiAgICAgICAgICAgIGxuZzogdHlwZW9mIHN0YXJ0TG9jYXRpb24ubG5nID09PSAnZnVuY3Rpb24nID8gc3RhcnRMb2NhdGlvbi5sbmcoKSA6IHN0YXJ0TG9jYXRpb24ubG5nXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkZXN0Q29vcmRzID0ge1xuICAgICAgICAgICAgbGF0OiB0eXBlb2YgZGVzdGluYXRpb24ubGF0ID09PSAnZnVuY3Rpb24nID8gZGVzdGluYXRpb24ubGF0KCkgOiBkZXN0aW5hdGlvbi5sYXQsXG4gICAgICAgICAgICBsbmc6IHR5cGVvZiBkZXN0aW5hdGlvbi5sbmcgPT09ICdmdW5jdGlvbicgPyBkZXN0aW5hdGlvbi5sbmcoKSA6IGRlc3RpbmF0aW9uLmxuZ1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gVmFsaWRhw6fDo28gZGFzIGNvb3JkZW5hZGFzIGNvbnZlcnRpZGFzXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhcnRDb29yZHMubGF0ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc3RhcnRDb29yZHMubG5nICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGRlc3RDb29yZHMubGF0ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGVzdENvb3Jkcy5sbmcgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvb3JkZW5hZGFzIGludsOhbGlkYXMgZm9ybmVjaWRhcycpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGHDp8OjbyBkb3MgcGFzc2FnZWlyb3MgZSBzdWFzIGNvb3JkZW5hZGFzXG4gICAgICAgIGlmICghcGFzc2VuZ2VycyB8fCBwYXNzZW5nZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaXN0YSBkZSBwYXNzYWdlaXJvcyBuw6NvIGZvcm5lY2lkYSBvdSB2YXppYScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGEgY29vcmRlbmFkYXMgZGUgdG9kb3Mgb3MgcGFzc2FnZWlyb3NcbiAgICAgICAgZm9yIChjb25zdCBwYXNzZW5nZXIgb2YgcGFzc2VuZ2Vycykge1xuICAgICAgICAgICAgaWYgKCFwYXNzZW5nZXIucG9zaXRpb24gfHwgXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBhc3Nlbmdlci5wb3NpdGlvbi5sYXQgIT09ICdudW1iZXInIHx8IFxuICAgICAgICAgICAgICAgIHR5cGVvZiBwYXNzZW5nZXIucG9zaXRpb24ubG5nICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29vcmRlbmFkYXMgaW52w6FsaWRhcyBwYXJhIG8gcGFzc2FnZWlybyAke3Bhc3Nlbmdlci5uYW1lIHx8ICdkZXNjb25oZWNpZG8nfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhIGRpc3TDom5jaWFzIGVzdGltYWRhcyB1c2FuZG8gSGF2ZXJzaW5lXG4gICAgICAgIGxldCB0b3RhbERpc3RhbmNlID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRDb29yZHMgPSBzdGFydENvb3JkcztcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgcGFzc2VuZ2VyIG9mIHBhc3NlbmdlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMYXQgPSB0eXBlb2YgY3VycmVudENvb3Jkcy5sYXQgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50Q29vcmRzLmxhdCgpIDogY3VycmVudENvb3Jkcy5sYXQ7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TG5nID0gdHlwZW9mIGN1cnJlbnRDb29yZHMubG5nID09PSAnZnVuY3Rpb24nID8gY3VycmVudENvb3Jkcy5sbmcoKSA6IGN1cnJlbnRDb29yZHMubG5nO1xuICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMYXQsXG4gICAgICAgICAgICAgICAgY3VycmVudExuZyxcbiAgICAgICAgICAgICAgICBwYXNzZW5nZXIucG9zaXRpb24ubGF0LFxuICAgICAgICAgICAgICAgIHBhc3Nlbmdlci5wb3NpdGlvbi5sbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50Q29vcmRzID0gcGFzc2VuZ2VyLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBZGljaW9uYSBkaXN0w6JuY2lhIGF0w6kgbyBkZXN0aW5vXG4gICAgICAgIGNvbnN0IGZpbmFsTGF0ID0gdHlwZW9mIGN1cnJlbnRDb29yZHMubGF0ID09PSAnZnVuY3Rpb24nID8gY3VycmVudENvb3Jkcy5sYXQoKSA6IGN1cnJlbnRDb29yZHMubGF0O1xuICAgICAgICBjb25zdCBmaW5hbExuZyA9IHR5cGVvZiBjdXJyZW50Q29vcmRzLmxuZyA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnRDb29yZHMubG5nKCkgOiBjdXJyZW50Q29vcmRzLmxuZztcbiAgICAgICAgdG90YWxEaXN0YW5jZSArPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKFxuICAgICAgICAgICAgZmluYWxMYXQsXG4gICAgICAgICAgICBmaW5hbExuZyxcbiAgICAgICAgICAgIGRlc3RDb29yZHMubGF0LFxuICAgICAgICAgICAgZGVzdENvb3Jkcy5sbmdcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVzdGltYSBkdXJhw6fDo28gKGFzc3VtaW5kbyB2ZWxvY2lkYWRlIG3DqWRpYSBkZSAzMCBrbS9oIG5vIHRyw6Juc2l0byB1cmJhbm8pXG4gICAgICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSAodG90YWxEaXN0YW5jZSAvIDMwKSAqIDYwOyAvLyBlbSBtaW51dG9zXG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhIGhvcsOhcmlvcyBlc3RpbWFkb3Mgc2ltcGxpZmljYWRvcyBwYXJhIGZhbGxiYWNrXG4gICAgICAgIGNvbnN0IHBpY2t1cFRpbWVzOiB7IHBhc3NlbmdlcjogUGFzc2VuZ2VyOyBlc3RpbWF0ZWRQaWNrdXBUaW1lOiBEYXRlIH1bXSA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgY3VycmVudFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWUpO1xuICAgICAgICBcbiAgICAgICAgcGFzc2VuZ2Vycy5mb3JFYWNoKChwYXNzZW5nZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBBZGljaW9uYSB0ZW1wbyBlc3RpbWFkbyBiYXNlYWRvIG5hIGRpc3TDom5jaWFcbiAgICAgICAgICAgIGNvbnN0IHRpbWVUb1Bhc3NlbmdlciA9IChpbmRleCArIDEpICogKHRvdGFsRHVyYXRpb24gLyBwYXNzZW5nZXJzLmxlbmd0aCk7XG4gICAgICAgICAgICBjdXJyZW50VGltZSA9IG5ldyBEYXRlKHN0YXJ0VGltZS5nZXRUaW1lKCkgKyB0aW1lVG9QYXNzZW5nZXIgKiA2MCAqIDEwMDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwaWNrdXBUaW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXNzZW5nZXIsXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkUGlja3VwVGltZTogbmV3IERhdGUoY3VycmVudFRpbWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmlhIHdheXBvaW50cyBiw6FzaWNvcyBwYXJhIGZhbGxiYWNrXG4gICAgICAgIGNvbnN0IGZhbGxiYWNrV2F5cG9pbnRzOiBnb29nbGUubWFwcy5MYXRMbmdbXSA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmFsbGJhY2tXYXlwb2ludHMucHVzaChuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHN0YXJ0Q29vcmRzLmxhdCwgc3RhcnRDb29yZHMubG5nKSk7XG4gICAgICAgICAgICBwYXNzZW5nZXJzLmZvckVhY2gocGFzc2VuZ2VyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGFzc2VuZ2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrV2F5cG9pbnRzLnB1c2gobmV3IGdvb2dsZS5tYXBzLkxhdExuZyhwYXNzZW5nZXIucG9zaXRpb24ubGF0LCBwYXNzZW5nZXIucG9zaXRpb24ubG5nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmYWxsYmFja1dheXBvaW50cy5wdXNoKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoZGVzdENvb3Jkcy5sYXQsIGRlc3RDb29yZHMubG5nKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm8gYW8gY3JpYXIgd2F5cG9pbnRzIGRlIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3YXlwb2ludHM6IGZhbGxiYWNrV2F5cG9pbnRzLFxuICAgICAgICAgICAgb3JkZXJlZFBhc3NlbmdlcnM6IHBhc3NlbmdlcnMsXG4gICAgICAgICAgICB0b3RhbERpc3RhbmNlLFxuICAgICAgICAgICAgdG90YWxEdXJhdGlvbixcbiAgICAgICAgICAgIHBvbHlsaW5lUGF0aDogW10sIC8vIFNlbSBwb2x5bGluZSBwYXJhIHJvdGEgZGUgZmFsbGJhY2tcbiAgICAgICAgICAgIHBpY2t1cFRpbWVzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXN0aW1hIG8gdGVtcG8gZGUgZW1iYXJxdWUgYmFzZWFkbyBubyBuw7ptZXJvIGRlIHBhc3NhZ2Vpcm9zXG4gICAgICovXG4gICAgZXN0aW1hdGVCb2FyZGluZ1RpbWUocGFzc2VuZ2VyQ291bnQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIC8vIEVzdGltYSAzMCBzZWd1bmRvcyBwb3IgcGFzc2FnZWlybyArIDEgbWludXRvIGJhc2VcbiAgICAgICAgcmV0dXJuIDEgKyAocGFzc2VuZ2VyQ291bnQgKiAwLjUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGEgbyBob3LDoXJpbyBlc3RpbWFkbyBkZSBjaGVnYWRhIHBhcmEgY2FkYSBwYXNzYWdlaXJvIChtw6l0b2RvIGFsdGVybmF0aXZvIHBhcmEgY29tcGF0aWJpbGlkYWRlKVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVBpY2t1cFRpbWVzRnJvbVNlZ21lbnRzKFxuICAgICAgICBzdGFydFRpbWU6IERhdGUsXG4gICAgICAgIG9yZGVyZWRQYXNzZW5nZXJzOiBQYXNzZW5nZXJbXSxcbiAgICAgICAgcm91dGVTZWdtZW50czogZ29vZ2xlLm1hcHMuRGlyZWN0aW9uc0xlZ1tdXG4gICAgKTogeyBwYXNzZW5nZXI6IFBhc3NlbmdlcjsgZXN0aW1hdGVkUGlja3VwVGltZTogRGF0ZSB9W10ge1xuICAgICAgICBjb25zdCBwaWNrdXBUaW1lczogeyBwYXNzZW5nZXI6IFBhc3NlbmdlcjsgZXN0aW1hdGVkUGlja3VwVGltZTogRGF0ZSB9W10gPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoc3RhcnRUaW1lKTtcblxuICAgICAgICBvcmRlcmVkUGFzc2VuZ2Vycy5mb3JFYWNoKChwYXNzZW5nZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCByb3V0ZVNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSByb3V0ZVNlZ21lbnRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IG5ldyBEYXRlKGN1cnJlbnRUaW1lLmdldFRpbWUoKSArIHNlZ21lbnQuZHVyYXRpb24udmFsdWUgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBpY2t1cFRpbWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhc3NlbmdlcixcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWRQaWNrdXBUaW1lOiBuZXcgRGF0ZShjdXJyZW50VGltZSlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBZGljaW9uYSB0ZW1wbyBkZSBlbWJhcnF1ZVxuICAgICAgICAgICAgY29uc3QgYm9hcmRpbmdUaW1lID0gdGhpcy5lc3RpbWF0ZUJvYXJkaW5nVGltZSgxKTtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoY3VycmVudFRpbWUuZ2V0VGltZSgpICsgYm9hcmRpbmdUaW1lICogNjAgKiAxMDAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2t1cFRpbWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlcmEgc3VnZXN0w7VlcyBkZSBvdGltaXphw6fDo28gcGFyYSB1bWEgcm90YVxuICAgICAqL1xuICAgIGdlbmVyYXRlT3B0aW1pemF0aW9uU3VnZ2VzdGlvbihwYXNzZW5nZXJDb3VudDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHBhc3NlbmdlckNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJBZGljaW9uZSBwYXNzYWdlaXJvcyBwYXJhIHZlciBzdWdlc3TDtWVzIGRlIG90aW1pemHDp8Ojby5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXNzZW5nZXJDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwi4pyFIFJvdGEgc2ltcGxlcyBjb20gMSBwYXNzYWdlaXJvIC0gc2VtIG5lY2Vzc2lkYWRlIGRlIG90aW1pemHDp8Ojby5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXNzZW5nZXJDb3VudCA8PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gYPCfmowgUm90YSBjb20gJHtwYXNzZW5nZXJDb3VudH0gcGFzc2FnZWlyb3MgLSBvdGltaXphw6fDo28gYXV0b23DoXRpY2EgYXBsaWNhZGEgcGFyYSBtaW5pbWl6YXIgZGlzdMOibmNpYS5gO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhc3NlbmdlckNvdW50IDw9IDYpIHtcbiAgICAgICAgICAgIHJldHVybiBg8J+OryBSb3RhIGNvbSAke3Bhc3NlbmdlckNvdW50fSBwYXNzYWdlaXJvcyAtIGFsZ29yaXRtbyBhdmFuw6dhZG8gYXBsaWNhZG8gKE5lYXJlc3QgTmVpZ2hib3IgKyAyLW9wdCkgcGFyYSBtw6F4aW1hIGVmaWNpw6puY2lhLmA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYOKaoSBSb3RhIGNvbXBsZXhhIGNvbSAke3Bhc3NlbmdlckNvdW50fSBwYXNzYWdlaXJvcyAtIG90aW1pemHDp8OjbyBpbnRlbGlnZW50ZSBhcGxpY2FkYS4gVGVtcG8gZXN0aW1hZG8gZGUgZWNvbm9taWE6ICR7TWF0aC5yb3VuZChwYXNzZW5nZXJDb3VudCAqIDAuOCl9IG1pbnV0b3MuYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGEgc2UgdW0gZW5kZXJlw6dvIHRlbSBjb29yZGVuYWRhcyB2w6FsaWRhc1xuICAgICAqL1xuICAgIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcsIHBvc2l0aW9uOiB7IGxhdDogbnVtYmVyOyBsbmc6IG51bWJlciB9KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghYWRkcmVzcyB8fCBhZGRyZXNzLnRyaW0oKS5sZW5ndGggPCAxMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwb3NpdGlvbiB8fCBcbiAgICAgICAgICAgIHR5cGVvZiBwb3NpdGlvbi5sYXQgIT09ICdudW1iZXInIHx8IFxuICAgICAgICAgICAgdHlwZW9mIHBvc2l0aW9uLmxuZyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIGlzTmFOKHBvc2l0aW9uLmxhdCkgfHwgXG4gICAgICAgICAgICBpc05hTihwb3NpdGlvbi5sbmcpIHx8XG4gICAgICAgICAgICBwb3NpdGlvbi5sYXQgPT09IDAgJiYgcG9zaXRpb24ubG5nID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRhIHRlbXBvIGVzdGltYWRvIGRlIGNvbGV0YVxuICAgICAqL1xuICAgIGZvcm1hdFBpY2t1cFRpbWUoZXN0aW1hdGVkVGltZTogRGF0ZSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGRpZmZNaW51dGVzID0gTWF0aC5yb3VuZCgoZXN0aW1hdGVkVGltZS5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpKSAvICgxMDAwICogNjApKTtcblxuICAgICAgICBpZiAoZGlmZk1pbnV0ZXMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJIb3LDoXJpbyBwYXNzYWRvXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlmZk1pbnV0ZXMgPCA2MCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2RpZmZNaW51dGVzfSBtaW5gO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKGRpZmZNaW51dGVzIC8gNjApO1xuICAgICAgICBjb25zdCBtaW51dGVzID0gZGlmZk1pbnV0ZXMgJSA2MDtcbiAgICAgICAgXG4gICAgICAgIGlmIChob3VycyA8IDI0KSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7aG91cnN9aCR7bWludXRlcyA+IDAgPyBgICR7bWludXRlc31taW5gIDogJyd9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlc3RpbWF0ZWRUaW1lLnRvTG9jYWxlRGF0ZVN0cmluZygncHQtQlInLCB7XG4gICAgICAgICAgICBkYXk6ICcyLWRpZ2l0JyxcbiAgICAgICAgICAgIG1vbnRoOiAnMi1kaWdpdCcsXG4gICAgICAgICAgICBob3VyOiAnMi1kaWdpdCcsXG4gICAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0J1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCByb3V0ZU9wdGltaXphdGlvblNlcnZpY2UgPSBuZXcgUm91dGVPcHRpbWl6YXRpb25TZXJ2aWNlKCk7Il0sIm5hbWVzIjpbIlJvdXRlT3B0aW1pemF0aW9uU2VydmljZSIsImNsZWFyRXhwaXJlZENhY2hlIiwibm93IiwiRGF0ZSIsImtleSIsInZhbHVlIiwicm91dGVDYWNoZSIsImVudHJpZXMiLCJ0aW1lc3RhbXAiLCJDQUNIRV9FWFBJUlkiLCJkZWxldGUiLCJnZXRDYWNoZUtleSIsIm9wdGlvbnMiLCJzdGFydExvY2F0aW9uIiwicGFzc2VuZ2VycyIsImRlc3RpbmF0aW9uIiwib3B0aW1pemVPcmRlciIsInN0YXJ0S2V5IiwibGF0IiwibG5nIiwiZGVzdEtleSIsInBhc3NlbmdlcnNLZXkiLCJtYXAiLCJwIiwiaWQiLCJwb3NpdGlvbiIsInNvcnQiLCJqb2luIiwiaW5pdGlhbGl6ZVNlcnZpY2UiLCJ3aW5kb3ciLCJ3YWl0Rm9yR29vZ2xlTWFwc0FQSSIsImdvb2dsZSIsIm1hcHMiLCJEaXJlY3Rpb25zU2VydmljZSIsImRpcmVjdGlvbnNTZXJ2aWNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJnb29nbGVNYXBzQXBpTG9hZGVkIiwiZXJyb3IiLCJFcnJvciIsImNvZGUiLCJhdHRlbXB0cyIsIm1heEF0dGVtcHRzIiwiY2hlY2tJbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImRldGFpbHMiLCJyb3V0ZUVycm9yIiwibWVzc2FnZSIsImNhbGN1bGF0ZURpc3RhbmNlIiwibGF0MSIsImxuZzEiLCJsYXQyIiwibG5nMiIsInRvRml4ZWQiLCJkaXN0YW5jZUNhY2hlIiwiaGFzIiwiZ2V0IiwiUiIsImRMYXQiLCJ0b1JhZCIsImRMbmciLCJhIiwiTWF0aCIsInNpbiIsImNvcyIsImMiLCJhdGFuMiIsInNxcnQiLCJkaXN0YW5jZSIsInNpemUiLCJzZXQiLCJQSSIsIm9wdGltaXplUGFzc2VuZ2VyT3JkZXIiLCJsZW5ndGgiLCJvcHRpbWl6ZWRPcmRlciIsIm5lYXJlc3ROZWlnaGJvck9wdGltaXphdGlvbiIsInR3b09wdEltcHJvdmVtZW50IiwidW52aXNpdGVkIiwiY3VycmVudExvY2F0aW9uIiwibmVhcmVzdEluZGV4IiwibmVhcmVzdERpc3RhbmNlIiwiaSIsIm5lYXJlc3RQYXNzZW5nZXIiLCJzcGxpY2UiLCJwdXNoIiwiTGF0TG5nIiwicm91dGUiLCJpbXByb3ZlZCIsImJlc3RSb3V0ZSIsImJlc3REaXN0YW5jZSIsImNhbGN1bGF0ZVRvdGFsUm91dGVEaXN0YW5jZSIsImoiLCJuZXdSb3V0ZSIsInR3b09wdFN3YXAiLCJuZXdEaXN0YW5jZSIsInRvdGFsRGlzdGFuY2UiLCJjYWxjdWxhdGVQaWNrdXBUaW1lcyIsIm9wdGltaXplZFBhc3NlbmdlcnMiLCJzdGFydFRpbWUiLCJwaWNrdXBUaW1lcyIsImN1cnJlbnRUaW1lIiwiYXZlcmFnZVNwZWVkIiwic3RvcFRpbWUiLCJwYXNzZW5nZXIiLCJ0cmF2ZWxUaW1lTWludXRlcyIsImdldFRpbWUiLCJlc3RpbWF0ZWRQaWNrdXBUaW1lIiwiY2FsY3VsYXRlT3B0aW1pemVkUm91dGUiLCJjYWNoZUtleSIsImNhY2hlZFJvdXRlIiwiY29uc29sZSIsImxvZyIsInN0YXJ0TGF0Iiwic3RhcnRMbmciLCJkZXN0TGF0IiwiZGVzdExuZyIsImlzTmFOIiwibmFtZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvcmRlcmVkUGFzc2VuZ2VycyIsIndheXBvaW50cyIsImxvY2F0aW9uIiwic3RvcG92ZXIiLCJyZXF1ZXN0Iiwib3JpZ2luIiwidHJhdmVsTW9kZSIsIlRyYXZlbE1vZGUiLCJEUklWSU5HIiwib3B0aW1pemVXYXlwb2ludHMiLCJkaXJlY3Rpb25zUmVzdWx0Iiwic3RhdHVzIiwiRGlyZWN0aW9uc1N0YXR1cyIsIk9LIiwicm91dGVzIiwibGVnIiwibGVncyIsInRvdGFsRHVyYXRpb24iLCJmb3JFYWNoIiwic2VnbWVudCIsImR1cmF0aW9uIiwicG9seWxpbmVQYXRoIiwib3ZlcnZpZXdfcGF0aCIsIkFycmF5IiwiaXNBcnJheSIsInBvaW50Iiwid2FybiIsIm9wdGltaXplZFdheXBvaW50cyIsInJlc3VsdCIsImZpbmRCZXN0Um91dGUiLCJmYWxsYmFja0Vycm9yIiwiY3JlYXRlRmFsbGJhY2tSb3V0ZSIsInN0YXJ0Q29vcmRzIiwiZGVzdENvb3JkcyIsImN1cnJlbnRDb29yZHMiLCJjdXJyZW50TGF0IiwiY3VycmVudExuZyIsImZpbmFsTGF0IiwiZmluYWxMbmciLCJpbmRleCIsInRpbWVUb1Bhc3NlbmdlciIsImZhbGxiYWNrV2F5cG9pbnRzIiwiZXN0aW1hdGVCb2FyZGluZ1RpbWUiLCJwYXNzZW5nZXJDb3VudCIsImNhbGN1bGF0ZVBpY2t1cFRpbWVzRnJvbVNlZ21lbnRzIiwicm91dGVTZWdtZW50cyIsImJvYXJkaW5nVGltZSIsImdlbmVyYXRlT3B0aW1pemF0aW9uU3VnZ2VzdGlvbiIsInJvdW5kIiwidmFsaWRhdGVBZGRyZXNzIiwiYWRkcmVzcyIsInRyaW0iLCJmb3JtYXRQaWNrdXBUaW1lIiwiZXN0aW1hdGVkVGltZSIsImRpZmZNaW51dGVzIiwiaG91cnMiLCJmbG9vciIsIm1pbnV0ZXMiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJkYXkiLCJtb250aCIsImhvdXIiLCJtaW51dGUiLCJNYXAiLCJyb3V0ZU9wdGltaXphdGlvblNlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/routeOptimizationService.ts\n"));

/***/ })

});